#!/usr/bin/env node

/**
 * Script para sincronizar configurações entre Frontend e Backend
 * Garante que todas as portas e URLs estejam sempre corretas
 */

const fs = require('fs');
const path = require('path');
const config = require('../config.shared.cjs');

console.log('🔄 Sincronizando configurações...\n');

// Atualizar .env do Frontend
const frontendEnvPath = path.join(__dirname, '..', '.env');
const frontendEnvContent = `# Auto-generated by sync-config.js - DO NOT EDIT MANUALLY
# Edit config.shared.js instead

VITE_API_URL=${config.urls.backendApi}
VITE_BACKEND_URL=${config.urls.backend}
VITE_SUPABASE_URL=${config.supabase.url}
VITE_SUPABASE_ANON_KEY=${config.supabase.anonKey}
`;

fs.writeFileSync(frontendEnvPath, frontendEnvContent);
console.log('✅ Frontend .env atualizado');

// Atualizar .env do Backend
const backendEnvPath = path.join(__dirname, '..', 'backend', '.env');
if (fs.existsSync(backendEnvPath)) {
  let backendEnv = fs.readFileSync(backendEnvPath, 'utf-8');
  
  // Atualizar PORT se existir
  if (backendEnv.includes('PORT=')) {
    backendEnv = backendEnv.replace(/PORT=\d+/, `PORT=${config.backend.port}`);
  } else {
    backendEnv += `\nPORT=${config.backend.port}`;
  }
  
  // Adicionar FRONTEND_URL se não existir
  if (!backendEnv.includes('FRONTEND_URL=')) {
    backendEnv += `\nFRONTEND_URL=${config.urls.frontend}`;
  } else {
    backendEnv = backendEnv.replace(/FRONTEND_URL=.*/, `FRONTEND_URL=${config.urls.frontend}`);
  }
  
  fs.writeFileSync(backendEnvPath, backendEnv);
  console.log('✅ Backend .env atualizado');
}

// Criar arquivo de configuração TypeScript para o Frontend
const tsConfigPath = path.join(__dirname, '..', 'src', 'config', 'app.config.ts');
const tsConfigContent = `/**
 * AUTO-GENERATED FILE - DO NOT EDIT
 * Edit config.shared.js instead and run npm run sync-config
 */

export const APP_CONFIG = {
  api: {
    baseUrl: '${config.urls.backendApi}',
    backendUrl: '${config.urls.backend}',
  },
  supabase: {
    url: '${config.supabase.url}',
    anonKey: '${config.supabase.anonKey}',
  },
  frontend: {
    port: ${config.frontend.port},
  },
  backend: {
    port: ${config.backend.port},
  },
} as const;
`;

// Criar diretório se não existir
const configDir = path.dirname(tsConfigPath);
if (!fs.existsSync(configDir)) {
  fs.mkdirSync(configDir, { recursive: true });
}

fs.writeFileSync(tsConfigPath, tsConfigContent);
console.log('✅ TypeScript config criado');

// Validar configurações
console.log('\n📊 Configurações atuais:');
console.log('================================');
console.log(`Backend Port: ${config.backend.port}`);
console.log(`Backend URL: ${config.urls.backend}`);
console.log(`API URL: ${config.urls.backendApi}`);
console.log(`Frontend Port: ${config.frontend.port}`);
console.log(`Frontend URL: ${config.urls.frontend}`);
console.log('================================');

// Verificar se as portas estão disponíveis
const net = require('net');

function checkPort(port, host) {
  return new Promise((resolve) => {
    const server = net.createServer();
    server.once('error', () => resolve(false));
    server.once('listening', () => {
      server.close();
      resolve(true);
    });
    server.listen(port, host);
  });
}

async function validatePorts() {
  const backendAvailable = await checkPort(config.backend.port, config.backend.host);
  const frontendAvailable = await checkPort(config.frontend.port, config.frontend.host);
  
  if (!backendAvailable) {
    console.log(`⚠️  Porta ${config.backend.port} já está em uso (provavelmente o backend está rodando)`);
  } else {
    console.log(`✅ Porta ${config.backend.port} está disponível para o backend`);
  }
  
  if (!frontendAvailable) {
    console.log(`⚠️  Porta ${config.frontend.port} já está em uso (provavelmente o frontend está rodando)`);
  } else {
    console.log(`✅ Porta ${config.frontend.port} está disponível para o frontend`);
  }
}

validatePorts().then(() => {
  console.log('\n✨ Sincronização concluída com sucesso!');
  console.log('📝 Reinicie os servidores para aplicar as mudanças.');
});