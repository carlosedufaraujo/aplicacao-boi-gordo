[
  {
    "projectId": "eb2bbb38-68be-43f6-8525-b39ffbf74a53",
    "testId": "163f7530-af44-4ed7-8187-c803625e8c10",
    "userId": "74b824b8-8031-7048-007a-cd1dd0a1f1a1",
    "title": "TC001-verify user login functionality",
    "description": "Test the /api/v1/auth/login endpoint to ensure users can log in with valid credentials and receive a JWT token. Verify that invalid credentials return a 401 status.",
    "code": "import requests\n\ndef test_verify_user_login_functionality():\n    base_url = \"http://localhost:3001\"\n    login_endpoint = f\"{base_url}/api/v1/auth/login\"\n    timeout = 30\n\n    valid_credentials = {\n        \"email\": \"carlosedufaraujo@outlook.com\",\n        \"password\": \"368308450Ce*\"\n    }\n    invalid_credentials = {\n        \"email\": \"carlosedufaraujo@outlook.com\",\n        \"password\": \"WrongPassword123!\"\n    }\n\n    headers = {\n        \"Content-Type\": \"application/json\"\n    }\n\n    # Test valid login - expect 200 and a token\n    try:\n        response = requests.post(login_endpoint, json=valid_credentials, headers=headers, timeout=timeout)\n        assert response.status_code == 200, f\"Expected 200 but got {response.status_code}\"\n        json_response = response.json()\n        assert \"token\" in json_response and isinstance(json_response[\"token\"], str) and len(json_response[\"token\"]) > 0, \"JWT token missing or invalid\"\n        assert \"status\" in json_response and json_response[\"status\"].lower() == \"success\", \"Status not success\"\n        assert \"user\" in json_response and isinstance(json_response[\"user\"], dict), \"User info missing or invalid\"\n    except requests.RequestException as e:\n        assert False, f\"Request failed: {e}\"\n\n    # Test invalid login - expect 401 Unauthorized\n    try:\n        response = requests.post(login_endpoint, json=invalid_credentials, headers=headers, timeout=timeout)\n        assert response.status_code == 401, f\"Expected 401 but got {response.status_code}\"\n    except requests.RequestException as e:\n        assert False, f\"Request failed: {e}\"\n\ntest_verify_user_login_functionality()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-09-14T14:10:31.442Z",
    "modified": "2025-09-14T14:10:55.280Z"
  },
  {
    "projectId": "eb2bbb38-68be-43f6-8525-b39ffbf74a53",
    "testId": "5f4e848d-7bec-4e06-be68-fe80b49c678d",
    "userId": "74b824b8-8031-7048-007a-cd1dd0a1f1a1",
    "title": "TC002-verify user registration process",
    "description": "Test the /api/v1/auth/register endpoint to ensure new users can register with valid data. Check that duplicate email registration returns a 409 status.",
    "code": "import requests\nimport uuid\n\nBASE_URL = \"http://localhost:3001\"\nREGISTER_ENDPOINT = \"/api/v1/auth/register\"\nTIMEOUT = 30\n\n# Basic token credentials for authType basic token (username, password)\nAUTH_USERNAME = \"carlosedufaraujo@outlook.com\"\nAUTH_PASSWORD = \"368308450Ce*\"\n\ndef get_basic_auth_header(username: str, password: str) -> dict:\n    import base64\n    token = base64.b64encode(f\"{username}:{password}\".encode()).decode()\n    return {\"Authorization\": f\"Basic {token}\"}\n\ndef test_verify_user_registration_process():\n    headers = {\n        \"Content-Type\": \"application/json\",\n        **get_basic_auth_header(AUTH_USERNAME, AUTH_PASSWORD),\n    }\n\n    # Generate unique email to avoid conflict at first register\n    unique_email = f\"testuser_{uuid.uuid4().hex}@example.com\"\n    payload = {\n        \"email\": unique_email,\n        \"password\": \"ValidPass123\",\n        \"name\": \"Test User\"\n    }\n\n    # Register new user - expect 201 Created\n    try:\n        response = requests.post(\n            BASE_URL + REGISTER_ENDPOINT,\n            json=payload,\n            headers=headers,\n            timeout=TIMEOUT,\n        )\n        assert response.status_code == 201, f\"Expected 201, got {response.status_code}\"\n    except requests.RequestException as e:\n        assert False, f\"Request exception during user registration: {e}\"\n\n    # Attempt registering the same email again - expect 409 Conflict\n    try:\n        response_duplicate = requests.post(\n            BASE_URL + REGISTER_ENDPOINT,\n            json=payload,\n            headers=headers,\n            timeout=TIMEOUT,\n        )\n        assert response_duplicate.status_code == 409, f\"Expected 409 on duplicate registration, got {response_duplicate.status_code}\"\n    except requests.RequestException as e:\n        assert False, f\"Request exception during duplicate user registration: {e}\"\n\ntest_verify_user_registration_process()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-09-14T14:10:31.448Z",
    "modified": "2025-09-14T14:11:06.722Z"
  },
  {
    "projectId": "eb2bbb38-68be-43f6-8525-b39ffbf74a53",
    "testId": "b82fc07b-0652-4851-a049-c40c8c759c85",
    "userId": "74b824b8-8031-7048-007a-cd1dd0a1f1a1",
    "title": "TC003-validate partner listing with authorization",
    "description": "Test the GET /api/v1/partners endpoint to verify that it returns a list of partners when authorized, supports pagination and filtering by partner type, and returns 401 when unauthorized.",
    "code": "import requests\nfrom requests.auth import HTTPBasicAuth\n\nBASE_URL = \"http://localhost:3001\"\nLOGIN_ENDPOINT = f\"{BASE_URL}/api/v1/auth/login\"\nPARTNERS_ENDPOINT = f\"{BASE_URL}/api/v1/partners\"\nTIMEOUT = 30\n\nUSERNAME = \"carlosedufaraujo@outlook.com\"\nPASSWORD = \"368308450Ce*\"\n\n\ndef test_validate_partner_listing_with_authorization():\n    # Step 1: Authenticate to get JWT token\n    login_payload = {\n        \"email\": USERNAME,\n        \"password\": PASSWORD\n    }\n    try:\n        login_response = requests.post(\n            LOGIN_ENDPOINT, json=login_payload, timeout=TIMEOUT\n        )\n        assert login_response.status_code == 200, f\"Login failed: {login_response.text}\"\n        login_data = login_response.json()\n        token = login_data.get(\"token\")\n        assert token, \"Token not found in login response\"\n    except Exception as e:\n        assert False, f\"Login request error: {str(e)}\"\n\n    headers_auth = {\n        \"Authorization\": f\"Bearer {token}\"\n    }\n\n    # Step 2: Authorized GET request without filters (list all partners)\n    try:\n        response = requests.get(PARTNERS_ENDPOINT, headers=headers_auth, timeout=TIMEOUT)\n        assert response.status_code == 200, f\"Authorized request failed: {response.text}\"\n        partners_list = response.json()\n        assert isinstance(partners_list, (list, dict)), \"Partners response is not a list or dict\"\n    except Exception as e:\n        assert False, f\"Authorized GET request error: {str(e)}\"\n\n    # Step 3: Authorized GET request with pagination parameters\n    params_pagination = {\n        \"page\": 1,\n        \"limit\": 5\n    }\n    try:\n        response_page = requests.get(\n            PARTNERS_ENDPOINT, headers=headers_auth, params=params_pagination, timeout=TIMEOUT\n        )\n        assert response_page.status_code == 200, f\"Pagination request failed: {response_page.text}\"\n        data_page = response_page.json()\n        assert isinstance(data_page, (list, dict)), \"Pagination response is not a list or dict\"\n    except Exception as e:\n        assert False, f\"Pagination GET request error: {str(e)}\"\n\n    # Step 4: Authorized GET request with partner type filter\n    filter_type = \"VENDOR\"\n    params_filter = {\n        \"type\": filter_type\n    }\n    try:\n        response_filter = requests.get(\n            PARTNERS_ENDPOINT, headers=headers_auth, params=params_filter, timeout=TIMEOUT\n        )\n        assert response_filter.status_code == 200, f\"Filter request failed: {response_filter.text}\"\n        data_filter = response_filter.json()\n        assert isinstance(data_filter, (list, dict)), \"Filtered response is not a list or dict\"\n        # Additional check: If list of partners, verify partner types if present\n        if isinstance(data_filter, list):\n            for partner in data_filter:\n                partner_type = partner.get(\"type\")\n                assert partner_type == filter_type, f\"Partner type mismatch: expected {filter_type}, got {partner_type}\"\n    except Exception as e:\n        assert False, f\"Filter GET request error: {str(e)}\"\n\n    # Step 5: Unauthorized request must return 401\n    try:\n        response_unauth = requests.get(PARTNERS_ENDPOINT, timeout=TIMEOUT)\n        assert response_unauth.status_code == 401, f\"Unauthorized access did not return 401, returned {response_unauth.status_code}\"\n    except Exception as e:\n        assert False, f\"Unauthorized GET request error: {str(e)}\"\n\n\ntest_validate_partner_listing_with_authorization()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-09-14T14:10:31.454Z",
    "modified": "2025-09-14T14:11:01.032Z"
  },
  {
    "projectId": "eb2bbb38-68be-43f6-8525-b39ffbf74a53",
    "testId": "e62b05d9-f3eb-4e7a-8279-a9aacd71d404",
    "userId": "74b824b8-8031-7048-007a-cd1dd0a1f1a1",
    "title": "TC004-validate partner creation with data validation",
    "description": "Test the POST /api/v1/partners endpoint to ensure new partners can be created with valid data and proper authorization. Verify that invalid data returns a 400 status and unauthorized access returns 401.",
    "code": "import requests\nfrom requests.auth import HTTPBasicAuth\n\nBASE_URL = \"http://localhost:3001\"\nLOGIN_URL = f\"{BASE_URL}/api/v1/auth/login\"\nPARTNERS_URL = f\"{BASE_URL}/api/v1/partners\"\nTIMEOUT = 30\n\nauth_username = \"carlosedufaraujo@outlook.com\"\nauth_password = \"368308450Ce*\"\n\n\ndef test_validate_partner_creation_with_data_validation():\n    # Step 1: Login to get JWT token\n    login_payload = {\n        \"email\": auth_username,\n        \"password\": auth_password\n    }\n    login_resp = requests.post(LOGIN_URL, json=login_payload, timeout=TIMEOUT)\n    assert login_resp.status_code == 200, \"Login failed with valid credentials\"\n    token = login_resp.json().get(\"token\")\n    assert token and isinstance(token, str), \"JWT token not found in login response\"\n\n    headers = {\n        \"Authorization\": f\"Bearer {token}\",\n        \"Content-Type\": \"application/json\"\n    }\n\n    created_partner_id = None\n\n    try:\n        # Step 2: Create partner with valid data\n        valid_partner_data = {\n            \"name\": \"Valid Partner Ltd\",\n            \"type\": \"VENDOR\",\n            \"cpfCnpj\": \"12345678000199\",\n            \"phone\": \"+5511999999999\",\n            \"email\": \"validpartner@example.com\",\n            \"address\": \"123 Fazenda Road\"\n        }\n        create_resp = requests.post(PARTNERS_URL, json=valid_partner_data, headers=headers, timeout=TIMEOUT)\n        assert create_resp.status_code == 201, f\"Expected 201 Created, got {create_resp.status_code}\"\n        create_resp_json = create_resp.json()\n        # Confirm returned data contains at least the id or name or similar\n        # Assuming API returns created partner data including a unique identifier \"id\"\n        created_partner_id = create_resp_json.get(\"id\") or create_resp_json.get(\"_id\")\n        assert created_partner_id is not None, \"Created partner ID not returned\"\n\n        # Step 3: Create partner with invalid data (missing required 'name')\n        invalid_partner_data = {\n            \"type\": \"VENDOR\",\n            \"cpfCnpj\": \"invalid_cpf\",\n            \"phone\": \"12345\",\n            \"email\": \"not-an-email\",\n            \"address\": \"\"\n        }\n        invalid_resp = requests.post(PARTNERS_URL, json=invalid_partner_data, headers=headers, timeout=TIMEOUT)\n        assert invalid_resp.status_code == 400, f\"Expected 400 Bad Request for invalid data, got {invalid_resp.status_code}\"\n\n        # Step 4: Attempt to create partner without authorization header\n        no_auth_resp = requests.post(PARTNERS_URL, json=valid_partner_data, timeout=TIMEOUT)\n        assert no_auth_resp.status_code == 401, f\"Expected 401 Unauthorized when no auth provided, got {no_auth_resp.status_code}\"\n\n    finally:\n        # Cleanup: delete the created partner if possible to keep test environment clean\n        if created_partner_id:\n            try:\n                delete_resp = requests.delete(f\"{PARTNERS_URL}/{created_partner_id}\", headers=headers, timeout=TIMEOUT)\n                # Accepting both 200 and 204 as successful delete response codes\n                assert delete_resp.status_code in (200, 204), f\"Failed to delete partner with id {created_partner_id}\"\n            except Exception:\n                pass\n\n\ntest_validate_partner_creation_with_data_validation()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 75, in <module>\n  File \"<string>\", line 42, in test_validate_partner_creation_with_data_validation\nAssertionError: Expected 201 Created, got 400\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-09-14T14:10:31.459Z",
    "modified": "2025-09-14T14:11:25.061Z"
  },
  {
    "projectId": "eb2bbb38-68be-43f6-8525-b39ffbf74a53",
    "testId": "57c461cc-04ae-4368-a2ed-78872e02db2e",
    "userId": "74b824b8-8031-7048-007a-cd1dd0a1f1a1",
    "title": "TC005-verify cattle purchase listing with authorization",
    "description": "Test the GET /api/v1/cattle-purchases endpoint to ensure it returns a list of cattle purchases when authorized and returns 401 when unauthorized.",
    "code": "import requests\nfrom requests.auth import HTTPBasicAuth\n\nBASE_URL = \"http://localhost:3001\"\nLOGIN_ENDPOINT = f\"{BASE_URL}/api/v1/auth/login\"\nCATTLE_PURCHASES_ENDPOINT = f\"{BASE_URL}/api/v1/cattle-purchases\"\n\nUSERNAME = \"carlosedufaraujo@outlook.com\"\nPASSWORD = \"368308450Ce*\"\n\ndef test_verify_cattle_purchase_listing_with_authorization():\n    timeout = 30\n    # Step 1: Log in to obtain JWT token\n    login_payload = {\"email\": USERNAME, \"password\": PASSWORD}\n    headers = {\"Content-Type\": \"application/json\"}\n\n    try:\n        login_response = requests.post(\n            LOGIN_ENDPOINT,\n            json=login_payload,\n            headers=headers,\n            timeout=timeout\n        )\n    except requests.RequestException as e:\n        assert False, f\"Login request failed: {e}\"\n\n    assert login_response.status_code == 200, f\"Login failed with status {login_response.status_code}\"\n    login_json = login_response.json()\n    token = login_json.get(\"token\")\n    assert token and isinstance(token, str), \"JWT token not found in login response\"\n\n    auth_headers = {\n        \"Authorization\": f\"Bearer {token}\"\n    }\n\n    # Step 2: Authorized GET request to /api/v1/cattle-purchases\n    try:\n        auth_response = requests.get(\n            CATTLE_PURCHASES_ENDPOINT,\n            headers=auth_headers,\n            timeout=timeout\n        )\n    except requests.RequestException as e:\n        assert False, f\"Authorized cattle purchases request failed: {e}\"\n\n    assert auth_response.status_code == 200, f\"Authorized request failed with status {auth_response.status_code}\"\n    try:\n        cattle_purchases = auth_response.json()\n    except ValueError:\n        assert False, \"Authorized response is not valid JSON\"\n\n    assert isinstance(cattle_purchases, (list, dict)), \"Authorized response is not a list or dict\"\n\n    # Step 3: Unauthorized GET request to /api/v1/cattle-purchases (no token)\n    try:\n        unauth_response = requests.get(\n            CATTLE_PURCHASES_ENDPOINT,\n            timeout=timeout\n        )\n    except requests.RequestException as e:\n        assert False, f\"Unauthorized cattle purchases request failed: {e}\"\n\n    assert unauth_response.status_code == 401, f\"Unauthorized request should return 401 but returned {unauth_response.status_code}\"\n\ntest_verify_cattle_purchase_listing_with_authorization()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-09-14T14:10:31.463Z",
    "modified": "2025-09-14T14:11:04.645Z"
  },
  {
    "projectId": "eb2bbb38-68be-43f6-8525-b39ffbf74a53",
    "testId": "e6ed5099-2642-496a-affc-266be3ed2c17",
    "userId": "74b824b8-8031-7048-007a-cd1dd0a1f1a1",
    "title": "TC006-validate cattle purchase creation with field validations",
    "description": "Test the POST /api/v1/cattle-purchases endpoint to verify that new cattle purchases can be created with all required fields validated, including vendorId, payerAccountId, purchaseDate, animalType, initialQuantity, purchaseWeight, carcassYield, pricePerArroba, and paymentType. Check for 400 status on invalid data and 401 on unauthorized access.",
    "code": "import requests\nfrom requests.auth import HTTPBasicAuth\nfrom datetime import datetime, timezone\nimport uuid\n\nBASE_URL = \"http://localhost:3001\"\nLOGIN_URL = f\"{BASE_URL}/api/v1/auth/login\"\nPARTNERS_URL = f\"{BASE_URL}/api/v1/partners\"\nCATTLE_PURCHASES_URL = f\"{BASE_URL}/api/v1/cattle-purchases\"\n\nUSERNAME = \"carlosedufaraujo@outlook.com\"\nPASSWORD = \"368308450Ce*\"\n\ndef test_tc006_validate_cattle_purchase_creation_with_field_validations():\n    # Helper function to get auth token via login\n    def get_auth_token():\n        payload = {\"email\": USERNAME, \"password\": PASSWORD}\n        resp = requests.post(LOGIN_URL, json=payload, timeout=30)\n        assert resp.status_code == 200, \"Login failed\"\n        token = resp.json().get(\"token\")\n        assert token, \"No token received\"\n        return token\n\n    # Helper to create a vendor partner and return its id by querying after creation\n    def create_vendor_partner(headers):\n        unique_name = f\"Vendor-{uuid.uuid4()}\"\n        vendor_data = {\n            \"name\": unique_name,\n            \"type\": \"VENDOR\",\n            \"cpfCnpj\": \"12345678901234\",\n            \"phone\": \"5599999999999\",\n            \"email\": f\"{unique_name}@example.com\",\n            \"address\": \"Rua Teste, 123\"\n        }\n        r = requests.post(PARTNERS_URL, json=vendor_data, headers=headers, timeout=30)\n        assert r.status_code == 201, f\"Failed to create vendor partner: {r.text}\"\n        # Query partner list to get ID\n        params = {\"type\": \"VENDOR\", \"page\": 1, \"limit\": 50}\n        list_resp = requests.get(PARTNERS_URL, headers=headers, params=params, timeout=30)\n        assert list_resp.status_code == 200, f\"Failed to list partners: {list_resp.text}\"\n        try:\n            partners_list = list_resp.json()\n        except Exception as ex:\n            assert False, f\"Failed to parse partner list response JSON: {ex}\"\n\n        if isinstance(partners_list, dict) and \"data\" in partners_list:\n            partners = partners_list[\"data\"]\n        elif isinstance(partners_list, list):\n            partners = partners_list\n        else:\n            assert False, \"Partner list response format is not as expected\"\n\n        for partner in partners:\n            if partner.get(\"name\") == unique_name:\n                return partner.get(\"id\")\n        assert False, \"Created vendor partner not found in list\"\n\n    # Helper to create a payer account partner of type OTHER and return id similarly\n    def create_payer_partner(headers):\n        unique_name = f\"Payer-{uuid.uuid4()}\"\n        payer_data = {\n            \"name\": unique_name,\n            \"type\": \"OTHER\",\n            \"cpfCnpj\": \"98765432100123\",\n            \"phone\": \"5511888888888\",\n            \"email\": f\"{unique_name}@example.com\",\n            \"address\": \"Avenida Exemplo, 456\"\n        }\n        r = requests.post(PARTNERS_URL, json=payer_data, headers=headers, timeout=30)\n        assert r.status_code == 201, f\"Failed to create payer partner: {r.text}\"\n        params = {\"type\": \"OTHER\", \"page\":1, \"limit\": 50}\n        list_resp = requests.get(PARTNERS_URL, headers=headers, params=params, timeout=30)\n        assert list_resp.status_code == 200, f\"Failed to list partners: {list_resp.text}\"\n        try:\n            partners_list = list_resp.json()\n        except Exception as ex:\n            assert False, f\"Failed to parse partner list response JSON: {ex}\"\n\n        if isinstance(partners_list, dict) and \"data\" in partners_list:\n            partners = partners_list[\"data\"]\n        elif isinstance(partners_list, list):\n            partners = partners_list\n        else:\n            assert False, \"Partner list response format is not as expected\"\n\n        for partner in partners:\n            if partner.get(\"name\") == unique_name:\n                return partner.get(\"id\")\n        assert False, \"Created payer partner not found in list\"\n\n    token = get_auth_token()\n    headers = {\n        \"Authorization\": f\"Bearer {token}\",\n        \"Content-Type\": \"application/json\"\n    }\n\n    vendor_id = None\n    payer_id = None\n    created_cattle_purchase_id = None\n\n    try:\n        # Create vendor and payer partners to use their IDs\n        vendor_id = create_vendor_partner(headers)\n        payer_id = create_payer_partner(headers)\n        assert vendor_id, \"Vendor partner ID not returned\"\n        assert payer_id, \"Payer account partner ID not returned\"\n\n        # 1) Test success case: create cattle purchase with all valid required fields\n        valid_payload = {\n            \"vendorId\": vendor_id,\n            \"payerAccountId\": payer_id,\n            \"purchaseDate\": datetime.now(timezone.utc).isoformat(),\n            \"animalType\": \"MALE\",\n            \"initialQuantity\": 10,\n            \"purchaseWeight\": 1500.5,\n            \"carcassYield\": 55.5,\n            \"pricePerArroba\": 300.0,\n            \"paymentType\": \"CASH\"\n        }\n        resp = requests.post(CATTLE_PURCHASES_URL, json=valid_payload, headers=headers, timeout=30)\n        assert resp.status_code == 201, f\"Valid cattle purchase creation failed: {resp.text}\"\n        json_resp = resp.json()\n        created_cattle_purchase_id = json_resp.get(\"id\") or json_resp.get(\"cattlePurchaseId\") or (json_resp.get(\"data\") and json_resp[\"data\"].get(\"id\"))\n        assert created_cattle_purchase_id, \"Created cattle purchase ID not returned\"\n\n        # 2) Test 400 Bad Request: missing required field (e.g. no vendorId)\n        invalid_payload_missing_vendor = valid_payload.copy()\n        invalid_payload_missing_vendor.pop(\"vendorId\")\n        resp400 = requests.post(CATTLE_PURCHASES_URL, json=invalid_payload_missing_vendor, headers=headers, timeout=30)\n        assert resp400.status_code == 400, f\"Expected 400 on missing vendorId, got {resp400.status_code}\"\n\n        # 3) Test 400 Bad Request: invalid field value (e.g. carcassYield > 100)\n        invalid_payload_bad_yield = valid_payload.copy()\n        invalid_payload_bad_yield[\"carcassYield\"] = 120.0\n        resp400b = requests.post(CATTLE_PURCHASES_URL, json=invalid_payload_bad_yield, headers=headers, timeout=30)\n        assert resp400b.status_code == 400, f\"Expected 400 on invalid carcassYield, got {resp400b.status_code}\"\n\n        # 4) Test 401 Unauthorized: no auth header\n        resp401 = requests.post(CATTLE_PURCHASES_URL, json=valid_payload, timeout=30)\n        assert resp401.status_code == 401, f\"Expected 401 unauthorized, got {resp401.status_code}\"\n\n    finally:\n        # Cleanup: delete created cattle purchase if possible\n        if created_cattle_purchase_id:\n            try:\n                del_resp = requests.delete(f\"{CATTLE_PURCHASES_URL}/{created_cattle_purchase_id}\", headers=headers, timeout=30)\n                # deletion might not be implemented; just ignore failures here\n            except Exception:\n                pass\n        # Cleanup vendor partner\n        if vendor_id:\n            try:\n                requests.delete(f\"{PARTNERS_URL}/{vendor_id}\", headers=headers, timeout=30)\n            except Exception:\n                pass\n        # Cleanup payer partner\n        if payer_id:\n            try:\n                requests.delete(f\"{PARTNERS_URL}/{payer_id}\", headers=headers, timeout=30)\n            except Exception:\n                pass\n\ntest_tc006_validate_cattle_purchase_creation_with_field_validations()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 163, in <module>\n  File \"<string>\", line 103, in test_tc006_validate_cattle_purchase_creation_with_field_validations\n  File \"<string>\", line 36, in create_vendor_partner\nAssertionError: Failed to create vendor partner: {\"status\":\"error\",\"message\":\"CPF/CNPJ já cadastrado\",\"statusCode\":409,\"stack\":\"Error: CPF/CNPJ já cadastrado\\n    at PartnerService.create (/Users/carloseduardo/App/aplicacao-boi-gordo/backend/src/services/partner.service.ts:75:15)\\n    at async create (/Users/carloseduardo/App/aplicacao-boi-gordo/backend/src/controllers/partner.controller.ts:98:21)\"}\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-09-14T14:10:31.468Z",
    "modified": "2025-09-14T14:12:06.492Z"
  },
  {
    "projectId": "eb2bbb38-68be-43f6-8525-b39ffbf74a53",
    "testId": "cc1fe71c-598a-4382-b7c5-9329fe5d5050",
    "userId": "74b824b8-8031-7048-007a-cd1dd0a1f1a1",
    "title": "TC007-verify expense listing with authorization",
    "description": "Test the GET /api/v1/expenses endpoint to ensure it returns a list of expenses when authorized and returns 401 when unauthorized.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:3001\"\nLOGIN_ENDPOINT = f\"{BASE_URL}/api/v1/auth/login\"\nEXPENSES_ENDPOINT = f\"{BASE_URL}/api/v1/expenses\"\nTIMEOUT = 30\n\nLOGIN_PAYLOAD = {\n    \"email\": \"carlosedufaraujo@outlook.com\",\n    \"password\": \"368308450Ce*\"\n}\n\ndef test_verify_expense_listing_with_authorization():\n    # Step 1: Perform login to get JWT token\n    try:\n        login_response = requests.post(LOGIN_ENDPOINT, json=LOGIN_PAYLOAD, timeout=TIMEOUT)\n    except Exception as e:\n        assert False, f\"Login request failed with exception: {e}\"\n\n    assert login_response.status_code == 200, f\"Expected status 200 for login, got {login_response.status_code}\"\n    try:\n        login_data = login_response.json()\n    except Exception:\n        assert False, \"Login response content is not valid JSON\"\n\n    assert \"token\" in login_data, \"Login response JSON does not contain 'token'\"\n    token = login_data[\"token\"]\n\n    headers = {\n        \"Authorization\": f\"Bearer {token}\"\n    }\n\n    # Authorized request using Bearer token\n    try:\n        authorized_response = requests.get(EXPENSES_ENDPOINT, headers=headers, timeout=TIMEOUT)\n    except Exception as e:\n        assert False, f\"Authorized request failed with exception: {e}\"\n\n    assert authorized_response.status_code == 200, f\"Expected status 200 for authorized request, got {authorized_response.status_code}\"\n    try:\n        expenses_data = authorized_response.json()\n    except Exception:\n        assert False, \"Response content is not valid JSON for authorized request\"\n    assert isinstance(expenses_data, dict), \"Response JSON should be an object containing expense data\"\n\n    # Unauthorized request (no auth)\n    try:\n        unauthorized_response = requests.get(EXPENSES_ENDPOINT, timeout=TIMEOUT)\n    except Exception as e:\n        assert False, f\"Unauthorized request failed with exception: {e}\"\n\n    assert unauthorized_response.status_code == 401, f\"Expected status 401 for unauthorized request, got {unauthorized_response.status_code}\"\n\n\ntest_verify_expense_listing_with_authorization()\n",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-09-14T14:10:31.473Z",
    "modified": "2025-09-14T14:11:57.886Z"
  },
  {
    "projectId": "eb2bbb38-68be-43f6-8525-b39ffbf74a53",
    "testId": "9939e48d-4cf9-45b3-873b-eedfb2ab76ef",
    "userId": "74b824b8-8031-7048-007a-cd1dd0a1f1a1",
    "title": "TC008-validate expense creation with required fields",
    "description": "Test the POST /api/v1/expenses endpoint to verify that new expenses can be created with required fields category, description, totalAmount, and dueDate. Check for 201 status on success and 401 on unauthorized access.",
    "code": "import requests\nfrom requests.auth import HTTPBasicAuth\nfrom datetime import datetime, timedelta\n\nBASE_URL = \"http://localhost:3001\"\nLOGIN_ENDPOINT = \"/api/v1/auth/login\"\nEXPENSES_ENDPOINT = \"/api/v1/expenses\"\n\nUSERNAME = \"carlosedufaraujo@outlook.com\"\nPASSWORD = \"368308450Ce*\"\n\ndef test_validate_expense_creation_with_required_fields():\n    timeout = 30\n\n    # Step 1: Authenticate user to get JWT token\n    login_payload = {\n        \"email\": USERNAME,\n        \"password\": PASSWORD\n    }\n    login_resp = requests.post(\n        BASE_URL + LOGIN_ENDPOINT,\n        json=login_payload,\n        timeout=timeout\n    )\n    assert login_resp.status_code == 200, f\"Login failed with status {login_resp.status_code}\"\n\n    login_data = login_resp.json()\n    token = login_data.get(\"token\")\n    assert token, \"No token received after login\"\n\n    headers_auth = {\n        \"Authorization\": f\"Bearer {token}\",\n        \"Content-Type\": \"application/json\"\n    }\n\n    # Step 2: Prepare valid expense data with required fields\n    due_date_iso = (datetime.utcnow() + timedelta(days=10)).isoformat() + \"Z\"\n    expense_payload = {\n        \"category\": \"Miscellaneous\",\n        \"description\": \"Vaccination for herd\",\n        \"totalAmount\": 350.75,\n        \"dueDate\": due_date_iso\n    }\n\n    # Test 201 Created on authorized request\n    resp = requests.post(\n        BASE_URL + EXPENSES_ENDPOINT,\n        json=expense_payload,\n        headers=headers_auth,\n        timeout=timeout\n    )\n    assert resp.status_code == 201, f\"Expected 201 Created, got {resp.status_code}\"\n\n    # Test 401 Unauthorized on no token\n    resp_unauth = requests.post(\n        BASE_URL + EXPENSES_ENDPOINT,\n        json=expense_payload,\n        timeout=timeout\n    )\n    assert resp_unauth.status_code == 401, f\"Expected 401 Unauthorized, got {resp_unauth.status_code}\"\n\ntest_validate_expense_creation_with_required_fields()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 62, in <module>\n  File \"<string>\", line 52, in test_validate_expense_creation_with_required_fields\nAssertionError: Expected 201 Created, got 400\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-09-14T14:10:31.478Z",
    "modified": "2025-09-14T14:11:44.913Z"
  },
  {
    "projectId": "eb2bbb38-68be-43f6-8525-b39ffbf74a53",
    "testId": "3e21c590-4faa-4d2b-ac46-6f6adc678cee",
    "userId": "74b824b8-8031-7048-007a-cd1dd0a1f1a1",
    "title": "TC009-verify dashboard statistics retrieval",
    "description": "Test the GET /api/v1/stats endpoint to ensure it returns accurate and real-time dashboard statistics including total cattle, active lots, occupied pens, total revenue, total expenses, net profit, average weight, mortality rate, date range, cash flow, and performance index.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:3001\"\nAUTH_CREDENTIALS = {\n    \"email\": \"carlosedufaraujo@outlook.com\",\n    \"password\": \"368308450Ce*\"\n}\nTIMEOUT = 30\n\ndef test_TC009_verify_dashboard_statistics_retrieval():\n    # Step 1: Authenticate and obtain JWT token\n    try:\n        auth_response = requests.post(\n            f\"{BASE_URL}/api/v1/auth/login\",\n            json={\"email\": AUTH_CREDENTIALS[\"email\"], \"password\": AUTH_CREDENTIALS[\"password\"]},\n            timeout=TIMEOUT\n        )\n    except requests.RequestException as e:\n        assert False, f\"Login request failed: {e}\"\n    assert auth_response.status_code == 200, f\"Login failed with status code {auth_response.status_code}\"\n    auth_data = auth_response.json()\n    assert \"token\" in auth_data and isinstance(auth_data[\"token\"], str) and len(auth_data[\"token\"]) > 0, \"Token missing in login response\"\n    token = auth_data[\"token\"]\n\n    headers = {\n        \"Authorization\": f\"Bearer {token}\"\n    }\n\n    # Step 2: Request dashboard statistics\n    try:\n        stats_response = requests.get(f\"{BASE_URL}/api/v1/stats\", headers=headers, timeout=TIMEOUT)\n    except requests.RequestException as e:\n        assert False, f\"Dashboard stats request failed: {e}\"\n    assert stats_response.status_code == 200, f\"Dashboard stats request failed with status code {stats_response.status_code}\"\n\n    stats = stats_response.json()\n\n    # Validate presence and type of all expected fields\n    expected_fields = {\n        \"totalCattle\": (int, float),\n        \"activeLots\": (int, float),\n        \"occupiedPens\": (int, float),\n        \"totalRevenue\": (int, float),\n        \"totalExpenses\": (int, float),\n        \"netProfit\": (int, float),\n        \"averageWeight\": (int, float),\n        \"mortalityRate\": (int, float),\n        \"dateRange\": str,\n        \"cashFlow\": dict,\n        \"performanceIndex\": dict\n    }\n\n    for field, expected_type in expected_fields.items():\n        assert field in stats, f\"Missing field in stats response: {field}\"\n        value = stats[field]\n        # If expected_type is a tuple, check if value is instance of any of them\n        if isinstance(expected_type, tuple):\n            assert isinstance(value, expected_type), f\"Field '{field}' expected to be one of types {expected_type} but got {type(value)}\"\n        else:\n            assert isinstance(value, expected_type), f\"Field '{field}' expected type {expected_type} but got {type(value)}\"\n\n    # Additional sanity checks (values should be non-negative where applicable)\n    numeric_fields = [\n        \"totalCattle\",\n        \"activeLots\",\n        \"occupiedPens\",\n        \"totalRevenue\",\n        \"totalExpenses\",\n        \"netProfit\",\n        \"averageWeight\",\n        \"mortalityRate\"\n    ]\n    for nf in numeric_fields:\n        val = stats[nf]\n        assert val >= 0, f\"Field '{nf}' should be non-negative, got {val}\"\n\ntest_TC009_verify_dashboard_statistics_retrieval()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-09-14T14:10:31.483Z",
    "modified": "2025-09-14T14:11:19.287Z"
  },
  {
    "projectId": "eb2bbb38-68be-43f6-8525-b39ffbf74a53",
    "testId": "dc603402-c19c-48e4-9dab-4eb562004454",
    "userId": "74b824b8-8031-7048-007a-cd1dd0a1f1a1",
    "title": "TC010-verify system health check endpoint",
    "description": "Test the GET /health endpoint to ensure it returns system health status with details such as status, timestamp, service name, version, uptime, database status, and server information.",
    "code": "import requests\n\ndef test_health_check_endpoint():\n    base_url = \"http://localhost:3001\"\n    url = f\"{base_url}/health\"\n    auth_username = \"carlosedufaraujo@outlook.com\"\n    auth_password = \"368308450Ce*\"\n    headers = {\n        \"Authorization\": f\"Basic {requests.auth._basic_auth_str(auth_username, auth_password).split(' ')[1]}\"\n    }\n\n    try:\n        response = requests.get(url, headers=headers, timeout=30)\n        # The health endpoint may not require authentication; if 401 is received, test fails.\n        assert response.status_code == 200, f\"Expected 200 OK, got {response.status_code}\"\n        data = response.json()\n        assert isinstance(data, dict), \"Response is not a JSON object\"\n        expected_keys = {\"status\", \"timestamp\", \"service\", \"version\", \"uptime\", \"database\", \"server\"}\n        missing_keys = expected_keys - data.keys()\n        assert not missing_keys, f\"Missing keys in response: {missing_keys}\"\n        assert isinstance(data[\"status\"], str) and data[\"status\"], \"Invalid or missing 'status'\"\n        assert isinstance(data[\"timestamp\"], str) and data[\"timestamp\"], \"Invalid or missing 'timestamp'\"\n        assert isinstance(data[\"service\"], str) and data[\"service\"], \"Invalid or missing 'service'\"\n        assert isinstance(data[\"version\"], str) and data[\"version\"], \"Invalid or missing 'version'\"\n        assert isinstance(data[\"uptime\"], (int, float)), \"Invalid or missing 'uptime'\"\n        assert isinstance(data[\"database\"], dict), \"'database' field is not an object\"\n        assert isinstance(data[\"server\"], dict), \"'server' field is not an object\"\n    except requests.exceptions.RequestException as e:\n        assert False, f\"Request failed: {e}\"\n\ntest_health_check_endpoint()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-09-14T14:10:31.489Z",
    "modified": "2025-09-14T14:11:23.285Z"
  }
]
