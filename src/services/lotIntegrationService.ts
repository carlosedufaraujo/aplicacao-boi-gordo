import { CattlePurchase, Expense, Revenue, CattlePurchase } from '../types';

// Tipo CalendarEvent baseado no componente CompleteCalendar
interface CalendarEvent {
  id: string;
  title: string;
  description?: string;
  type: 'purchase' | 'sale' | 'health' | 'transport' | 'finance' | 'general' | 'dre' | 'payment';
  date: Date;
  time?: string;
  location?: string;
  participants?: string[];
  status?: 'scheduled' | 'in_progress' | 'completed' | 'cancelled' | 'overdue';
  priority?: 'low' | 'medium' | 'high';
  recurring?: boolean;
  tags?: string[];
  color?: string;
  relatedId?: string;
  amount?: number;
  autoGenerated?: boolean;
}
import { dataService } from './supabaseData';
import { addDays, format } from 'date-fns';
import { ptBR } from 'date-fns/locale';

/**
 * Servi√ßo respons√°vel por integrar um novo lote com todos os m√≥dulos do sistema
 */
export class LotIntegrationService {
  /**
   * Executa todas as integra√ß√µes necess√°rias quando um lote √© criado
   */
  static async integrateNewLot(purchaseOrder: CattlePurchase): Promise<void> {
    console.log('üîÑ Iniciando integra√ß√µes para novo lote:', purchaseOrder.code);
    
    try {
      // 1. Integra√ß√£o com p√°gina Lotes (criar CattlePurchase)
      const cattleLot = await this.createCattlePurchase(purchaseOrder);
      
      // 2. Integra√ß√£o com Centro Financeiro (criar despesas)
      await this.createFinancialEntries(purchaseOrder);
      
      // 3. Integra√ß√£o com Currais (alocar lote em currais dispon√≠veis)
      await this.allocateLotToPens(cattleLot, purchaseOrder);
      
      // 4. Integra√ß√£o com Calend√°rio (criar eventos)
      await this.createCalendarEvents(purchaseOrder);
      
      // 5. Integra√ß√£o com DRE (os dados j√° ser√£o puxados automaticamente via hooks)
      // O DRE usa os dados de expenses e revenues que acabamos de criar
      
      // 6. Integra√ß√£o com Concilia√ß√£o (criar transa√ß√µes pendentes)
      await this.createReconciliationEntries(purchaseOrder);
      
      console.log('‚úÖ Integra√ß√µes conclu√≠das para lote:', purchaseOrder.code);
      return cattleLot;
    } catch (error) {
      console.error('‚ùå Erro nas integra√ß√µes do lote:', error);
      throw error;
    }
  }

  /**
   * Cria o CattlePurchase na p√°gina de Lotes baseado na ordem de compra
   */
  private static async createCattlePurchase(purchaseOrder: CattlePurchase): Promise<CattlePurchase> {
    // Calcular peso da carca√ßa baseado no RC%
    const rcPercentage = purchaseOrder.rcPercentage || 50;
    const carcassWeight = purchaseOrder.totalWeight * (rcPercentage / 100);
    const arrobas = carcassWeight / 15; // 1 arroba = 15kg

    // Gerar ID √∫nico para o lote
    const lotId = `lot_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    
    // Garantir que temos um lotNumber v√°lido - usar lotCode ou code ou gerar um novo
    const lotNumber = purchaseOrder.lotCode || purchaseOrder.code || `LOT-${Date.now()}`;
    
    // Garantir que temos valores v√°lidos para todos os campos obrigat√≥rios
    const entryDate = purchaseOrder.arrivalDate || purchaseOrder.purchaseDate || new Date().toISOString();
    const entryWeight = purchaseOrder.totalWeight || 0;
    const entryQuantity = purchaseOrder.currentQuantity || 0;
    const totalValue = purchaseOrder.totalValue || 0;
    
    // Log para debug
    console.log('üìù Criando lote com dados:', {
      id: lotId,
      lotNumber: lotNumber,
      purchaseId: purchaseOrder.id,
      entryDate: entryDate,
      entryWeight: entryWeight,
      entryQuantity: entryQuantity
    });
    
    // Gerar timestamps
    const now = new Date().toISOString();
    
    // Usar objeto simples que corresponde exatamente √† estrutura da tabela Supabase
    const cattleLotData = {
      id: lotId,
      lotNumber: lotNumber,
      purchaseId: purchaseOrder.id,
      entryDate: entryDate,
      entryWeight: entryWeight,
      entryQuantity: entryQuantity,
      currentQuantity: entryQuantity,
      acquisitionCost: totalValue,
      healthCost: 0,
      feedCost: 0,
      operationalCost: 0,
      freightCost: purchaseOrder.freightCost || 0,
      otherCosts: 0,
      totalCost: totalValue,
      deathCount: 0,
      status: 'ACTIVE',
      createdAt: now,
      updatedAt: now
    };

    try {
      const newCattlePurchase = await dataService.createCattlePurchase(cattleLotData);
      console.log('üêÑ Lote de gado criado:', newCattlePurchase.lotNumber);
      return newCattlePurchase;
    } catch (error) {
      console.error('‚ùå Erro ao criar lote de gado:', error);
      throw error;
    }
  }

  /**
   * Aloca o lote em currais dispon√≠veis
   */
  private static async allocateLotToPens(cattleLot: CattlePurchase, purchaseOrder: CattlePurchase): Promise<void> {
    try {
      // Buscar currais dispon√≠veis
      // Por enquanto, apenas log - a implementa√ß√£o completa depende da estrutura de currais
      console.log('üè† Alocando lote em currais:', cattleLot.lotNumber);
      
      // Aqui seria implementada a l√≥gica para:
      // 1. Buscar currais dispon√≠veis com capacidade suficiente
      // 2. Criar links entre lote e currais (lot_pen_links)
      // 3. Atualizar ocupa√ß√£o dos currais
      // 4. Registrar movimenta√ß√£o de animais
      
      const allocationData = {
        lotId: cattleLot.id,
        currentQuantity: cattleLot.currentQuantity,
        allocationDate: cattleLot.arrivalDate,
        status: 'ACTIVE'
      };
      
      console.log('üîó Dados de aloca√ß√£o preparados:', allocationData);
      
      // TODO: Implementar cria√ß√£o de lot_pen_links quando estrutura estiver definida
      // await dataService.createLotPenLink(allocationData);
      
    } catch (error) {
      console.error('‚ùå Erro ao alocar lote em currais:', error);
      // N√£o falha a integra√ß√£o se a aloca√ß√£o falhar
    }
  }

  /**
   * Cria as despesas no Centro Financeiro baseadas na ordem de compra
   */
  private static async createFinancialEntries(purchaseOrder: CattlePurchase): Promise<void> {
    const expenses: Omit<Expense, 'id' | 'createdAt' | 'updatedAt'>[] = [];
    
    // 1. Despesa principal - Compra de animais
    const animalPurchaseExpense: Omit<Expense, 'id' | 'createdAt' | 'updatedAt'> = {
      description: `Compra de Gado - Lote ${purchaseOrder.code}`,
      amount: purchaseOrder.totalValue,
      category: 'animal_purchase',
      date: purchaseOrder.purchaseDate,
      dueDate: purchaseOrder.paymentDate || addDays(new Date(purchaseOrder.purchaseDate), 30),
      status: 'pending',
      payerAccountId: null, // Ser√° definido pelo usu√°rio posteriormente
      costCenter: 'ACQUISITION',
      tags: [`lote-${purchaseOrder.code}`, 'compra-gado'],
      lotId: purchaseOrder.id,
      supplierId: purchaseOrder.vendorId,
      invoiceNumber: purchaseOrder.code,
      impactsCashFlow: true,
      isRecurring: false
    };
    expenses.push(animalPurchaseExpense);

    // 2. Comiss√£o do corretor (se houver)
    if (purchaseOrder.brokerId && purchaseOrder.brokerCommission && purchaseOrder.brokerCommission > 0) {
      const commissionExpense: Omit<Expense, 'id' | 'createdAt' | 'updatedAt'> = {
        description: `Comiss√£o Corretor - Lote ${purchaseOrder.code}`,
        amount: purchaseOrder.brokerCommission,
        category: 'commission',
        date: purchaseOrder.purchaseDate,
        dueDate: addDays(new Date(purchaseOrder.purchaseDate), 15), // Comiss√£o geralmente paga antes
        status: 'pending',
        payerAccountId: null,
        costCenter: 'ACQUISITION',
        tags: [`lote-${purchaseOrder.code}`, 'comissao-corretor'],
        lotId: purchaseOrder.id,
        supplierId: purchaseOrder.brokerId,
        impactsCashFlow: true,
        isRecurring: false
      };
      expenses.push(commissionExpense);
    }

    // 3. Frete (se houver)
    if (purchaseOrder.freightCost && purchaseOrder.freightCost > 0) {
      const freightExpense: Omit<Expense, 'id' | 'createdAt' | 'updatedAt'> = {
        description: `Frete - Lote ${purchaseOrder.code}`,
        amount: purchaseOrder.freightCost,
        category: 'freight',
        date: purchaseOrder.purchaseDate,
        dueDate: addDays(new Date(purchaseOrder.purchaseDate), 7), // Frete geralmente pago rapidamente
        status: 'pending',
        payerAccountId: null,
        costCenter: 'ACQUISITION',
        tags: [`lote-${purchaseOrder.code}`, 'frete'],
        lotId: purchaseOrder.id,
        impactsCashFlow: true,
        isRecurring: false
      };
      expenses.push(freightExpense);
    }

    // 4. Custos adicionais (se houver)
    if (purchaseOrder.additionalCosts && purchaseOrder.additionalCosts.length > 0) {
      for (const additionalCost of purchaseOrder.additionalCosts) {
        const additionalExpense: Omit<Expense, 'id' | 'createdAt' | 'updatedAt'> = {
          description: `${additionalCost.description} - Lote ${purchaseOrder.code}`,
          amount: additionalCost.value,
          category: 'acquisition_other',
          date: purchaseOrder.purchaseDate,
          dueDate: addDays(new Date(purchaseOrder.purchaseDate), 30),
          status: 'pending',
          payerAccountId: null,
          costCenter: 'ACQUISITION',
          tags: [`lote-${purchaseOrder.code}`, 'custo-adicional'],
          lotId: purchaseOrder.id,
          impactsCashFlow: true,
          isRecurring: false
        };
        expenses.push(additionalExpense);
      }
    }

    // Criar todas as despesas no Supabase
    for (const expense of expenses) {
      await dataService.createExpense(expense);
      console.log('üí∞ Despesa criada:', expense.description);
    }
  }

  /**
   * Cria eventos no calend√°rio relacionados ao lote
   */
  private static async createCalendarEvents(purchaseOrder: CattlePurchase): Promise<void> {
    const events: Omit<CalendarEvent, 'id'>[] = [];

    // 1. Evento de chegada do gado
    const arrivalEvent: Omit<CalendarEvent, 'id'> = {
      title: `Chegada do Gado - Lote ${purchaseOrder.code}`,
      description: `Chegada de ${purchaseOrder.currentQuantity} cabe√ßas de gado do fornecedor ${purchaseOrder.vendorName}`,
      date: new Date(purchaseOrder.arrivalDate || purchaseOrder.purchaseDate),
      type: 'purchase',
      priority: 'high',
      status: 'scheduled',
      relatedId: purchaseOrder.id,
      tags: [`lote-${purchaseOrder.code}`, 'chegada-gado'],
      location: purchaseOrder.destinationLocation || 'Fazenda',
      participants: [],
      recurring: false,
      autoGenerated: true
    };
    events.push(arrivalEvent);

    // 2. Evento de pagamento (se data definida)
    if (purchaseOrder.paymentDate) {
      const paymentEvent: Omit<CalendarEvent, 'id'> = {
        title: `Pagamento - Lote ${purchaseOrder.code}`,
        description: `Pagamento de R$ ${purchaseOrder.totalValue.toLocaleString('pt-BR', { minimumFractionDigits: 2 })} para ${purchaseOrder.vendorName}`,
        date: new Date(purchaseOrder.paymentDate),
        type: 'finance',
        priority: 'high',
        status: 'scheduled',
        relatedId: purchaseOrder.id,
        tags: [`lote-${purchaseOrder.code}`, 'pagamento'],
        participants: [],
        recurring: false,
        amount: purchaseOrder.totalValue,
        autoGenerated: true
      };
      events.push(paymentEvent);
    }

    // 3. Evento de primeira pesagem (7 dias ap√≥s chegada)
    const firstWeighingDate = addDays(new Date(purchaseOrder.arrivalDate || purchaseOrder.purchaseDate), 7);
    const firstWeighingEvent: Omit<CalendarEvent, 'id'> = {
      title: `Primeira Pesagem - Lote ${purchaseOrder.code}`,
      description: `Primeira pesagem para controle de peso do lote`,
      date: firstWeighingDate,
      type: 'general',
      priority: 'medium',
      status: 'scheduled',
      relatedId: purchaseOrder.id,
      tags: [`lote-${purchaseOrder.code}`, 'pesagem'],
      participants: [],
      recurring: false,
      autoGenerated: true
    };
    events.push(firstWeighingEvent);

    // 4. Evento de vacina√ß√£o (se necess√°rio - 15 dias ap√≥s chegada)
    const vaccinationDate = addDays(new Date(purchaseOrder.arrivalDate || purchaseOrder.purchaseDate), 15);
    const vaccinationEvent: Omit<CalendarEvent, 'id'> = {
      title: `Vacina√ß√£o - Lote ${purchaseOrder.code}`,
      description: `Vacina√ß√£o e cuidados veterin√°rios do lote`,
      date: vaccinationDate,
      type: 'health',
      priority: 'high',
      status: 'scheduled',
      relatedId: purchaseOrder.id,
      tags: [`lote-${purchaseOrder.code}`, 'vacinacao', 'saude'],
      participants: [],
      recurring: false,
      autoGenerated: true
    };
    events.push(vaccinationEvent);

    // Criar todos os eventos no Supabase
    for (const event of events) {
      // Verificar se existe tabela de eventos no Supabase
      try {
        // await dataService.createCalendarEvent(event);
        console.log('üìÖ Evento criado:', event.title);
      } catch (error) {
        console.log('‚ö†Ô∏è Tabela de eventos n√£o existe ainda, pulando cria√ß√£o de eventos');
        break;
      }
    }
  }

  /**
   * Cria entradas para concilia√ß√£o banc√°ria
   */
  private static async createReconciliationEntries(purchaseOrder: CattlePurchase): Promise<void> {
    // Por enquanto, apenas log - a implementa√ß√£o completa depende da estrutura da concilia√ß√£o
    console.log('üè¶ Criando entradas para concilia√ß√£o banc√°ria do lote:', purchaseOrder.code);
    
    // Aqui seria criado um registro de transa√ß√£o esperada para concilia√ß√£o
    // quando o pagamento for efetuado
    const expectedTransaction = {
      description: `Pagamento Lote ${purchaseOrder.code}`,
      amount: -purchaseOrder.totalValue, // Sa√≠da de dinheiro
      expectedDate: purchaseOrder.paymentDate || addDays(new Date(purchaseOrder.purchaseDate), 30),
      type: 'expense',
      category: 'animal_purchase',
      lotId: purchaseOrder.id,
      status: 'expected'
    };
    
    console.log('üí≥ Transa√ß√£o esperada para concilia√ß√£o:', expectedTransaction);
  }

  /**
   * Atualiza as integra√ß√µes quando um lote √© modificado
   */
  static async updateLotIntegrations(purchaseOrder: CattlePurchase): Promise<void> {
    console.log('üîÑ Atualizando integra√ß√µes para lote modificado:', purchaseOrder.code);
    
    // Aqui seria implementada a l√≥gica para atualizar despesas, eventos, etc.
    // quando uma ordem de compra √© modificada
  }

  /**
   * Remove as integra√ß√µes quando um lote √© exclu√≠do
   */
  static async removeLotIntegrations(purchaseId: string): Promise<void> {
    console.log('üóëÔ∏è Removendo integra√ß√µes para lote exclu√≠do:', purchaseId);
    
    try {
      // Remover despesas relacionadas
      // await dataService.deleteExpensesByLotId(purchaseId);
      
      // Remover eventos relacionados
      // await dataService.deleteCalendarEventsByLotId(purchaseId);
      
      console.log('‚úÖ Integra√ß√µes removidas com sucesso');
    } catch (error) {
      console.error('‚ùå Erro ao remover integra√ß√µes:', error);
      throw error;
    }
  }
}
