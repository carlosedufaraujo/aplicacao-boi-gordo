import { CattlePurchase, Expense, Revenue, CattlePurchase } from '../types';

// Tipo CalendarEvent baseado no componente CompleteCalendar
interface CalendarEvent {
  id: string;
  title: string;
  description?: string;
  type: 'purchase' | 'sale' | 'health' | 'transport' | 'finance' | 'general' | 'dre' | 'payment';
  date: Date;
  time?: string;
  location?: string;
  participants?: string[];
  status?: 'scheduled' | 'in_progress' | 'completed' | 'cancelled' | 'overdue';
  priority?: 'low' | 'medium' | 'high';
  recurring?: boolean;
  tags?: string[];
  color?: string;
  relatedId?: string;
  amount?: number;
  autoGenerated?: boolean;
}
import { dataService } from './supabaseData';
import { addDays, format } from 'date-fns';
import { ptBR } from 'date-fns/locale';

/**
 * Serviço responsável por integrar um novo lote com todos os módulos do sistema
 */
export class LotIntegrationService {
  /**
   * Executa todas as integrações necessárias quando um lote é criado
   */
  static async integrateNewLot(purchaseOrder: CattlePurchase): Promise<void> {
    
    try {
      // 1. Integração com página Lotes (criar CattlePurchase)
      const cattleLot = await this.createCattlePurchase(purchaseOrder);
      
      // 2. Integração com Centro Financeiro (criar despesas)
      await this.createFinancialEntries(purchaseOrder);
      
      // 3. Integração com Currais (alocar lote em currais disponíveis)
      await this.allocateLotToPens(cattleLot, purchaseOrder);
      
      // 4. Integração com Calendário (criar eventos)
      await this.createCalendarEvents(purchaseOrder);
      
      // 5. Integração com DRE (os dados já serão puxados automaticamente via hooks)
      // O DRE usa os dados de expenses e revenues que acabamos de criar
      
      // 6. Integração com Conciliação (criar transações pendentes)
      await this.createReconciliationEntries(purchaseOrder);
      
      return cattleLot;
    } catch (error) {
      console.error('❌ Erro nas integrações do lote:', error);
      throw error;
    }
  }

  /**
   * Cria o CattlePurchase na página de Lotes baseado na ordem de compra
   */
  private static async createCattlePurchase(purchaseOrder: CattlePurchase): Promise<CattlePurchase> {
    // Calcular peso da carcaça baseado no RC%
    const rcPercentage = purchaseOrder.rcPercentage || 50;
    const carcassWeight = purchaseOrder.totalWeight * (rcPercentage / 100);
    const arrobas = carcassWeight / 15; // 1 arroba = 15kg

    // Gerar ID único para o lote
    const lotId = `lot_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    
    // Garantir que temos um lotNumber válido - usar lotCode ou code ou gerar um novo
    const lotNumber = purchaseOrder.lotCode || purchaseOrder.code || `LOT-${Date.now()}`;
    
    // Garantir que temos valores válidos para todos os campos obrigatórios
    const entryDate = purchaseOrder.arrivalDate || purchaseOrder.purchaseDate || new Date().toISOString();
    const entryWeight = purchaseOrder.totalWeight || 0;
    const entryQuantity = purchaseOrder.currentQuantity || 0;
    const totalValue = purchaseOrder.totalValue || 0;
    
    // Debug removido para limpeza de código
    
    // Gerar timestamps
    const now = new Date().toISOString();
    
    // Usar objeto simples que corresponde exatamente à estrutura da tabela Supabase
    const cattleLotData = {
      id: lotId,
      lotNumber: lotNumber,
      purchaseId: purchaseOrder.id,
      entryDate: entryDate,
      entryWeight: entryWeight,
      entryQuantity: entryQuantity,
      currentQuantity: entryQuantity,
      acquisitionCost: totalValue,
      healthCost: 0,
      feedCost: 0,
      operationalCost: 0,
      freightCost: purchaseOrder.freightCost || 0,
      otherCosts: 0,
      totalCost: totalValue,
      deathCount: 0,
      status: 'ACTIVE',
      createdAt: now,
      updatedAt: now
    };

    try {
      const newCattlePurchase = await dataService.createCattlePurchase(cattleLotData);
      return newCattlePurchase;
    } catch (error) {
      console.error('❌ Erro ao criar lote de gado:', error);
      throw error;
    }
  }

  /**
   * Aloca o lote em currais disponíveis
   */
  private static async allocateLotToPens(cattleLot: CattlePurchase, purchaseOrder: CattlePurchase): Promise<void> {
    try {
      // Buscar currais disponíveis
      // Por enquanto, apenas log - a implementação completa depende da estrutura de currais
      
      // Aqui seria implementada a lógica para:
      // 1. Buscar currais disponíveis com capacidade suficiente
      // 2. Criar links entre lote e currais (lot_pen_links)
      // 3. Atualizar ocupação dos currais
      // 4. Registrar movimentação de animais
      
      const allocationData = {
        lotId: cattleLot.id,
        currentQuantity: cattleLot.currentQuantity,
        allocationDate: cattleLot.arrivalDate,
        status: 'ACTIVE'
      };
      // TODO: Implementar criação de lot_pen_links quando estrutura estiver definida
      // await dataService.createLotPenLink(allocationData);
      
    } catch (error) {
      console.error('❌ Erro ao alocar lote em currais:', error);
      // Não falha a integração se a alocação falhar
    }
  }

  /**
   * Cria as despesas no Centro Financeiro baseadas na ordem de compra
   */
  private static async createFinancialEntries(purchaseOrder: CattlePurchase): Promise<void> {
    const expenses: Omit<Expense, 'id' | 'createdAt' | 'updatedAt'>[] = [];
    
    // 1. Despesa principal - Compra de animais
    const animalPurchaseExpense: Omit<Expense, 'id' | 'createdAt' | 'updatedAt'> = {
      description: `Compra de Gado - ${purchaseOrder.code}`,
      amount: purchaseOrder.totalValue,
      category: 'animal_purchase',
      date: purchaseOrder.purchaseDate,
      dueDate: purchaseOrder.paymentDate || addDays(new Date(purchaseOrder.purchaseDate), 30),
      status: 'pending',
      payerAccountId: null, // Será definido pelo usuário posteriormente
      costCenter: 'ACQUISITION',
      tags: [`lote-${purchaseOrder.code}`, 'compra-gado'],
      lotId: purchaseOrder.id,
      supplierId: purchaseOrder.vendorId,
      invoiceNumber: purchaseOrder.code,
      impactsCashFlow: true,
      isRecurring: false
    };
    expenses.push(animalPurchaseExpense);

    // 2. Comissão do corretor (se houver)
    if (purchaseOrder.brokerId && purchaseOrder.brokerCommission && purchaseOrder.brokerCommission > 0) {
      const commissionExpense: Omit<Expense, 'id' | 'createdAt' | 'updatedAt'> = {
        description: `Comissão Corretor - ${purchaseOrder.code}`,
        amount: purchaseOrder.brokerCommission,
        category: 'commission',
        date: purchaseOrder.purchaseDate,
        dueDate: addDays(new Date(purchaseOrder.purchaseDate), 15), // Comissão geralmente paga antes
        status: 'pending',
        payerAccountId: null,
        costCenter: 'ACQUISITION',
        tags: [`lote-${purchaseOrder.code}`, 'comissao-corretor'],
        lotId: purchaseOrder.id,
        supplierId: purchaseOrder.brokerId,
        impactsCashFlow: true,
        isRecurring: false
      };
      expenses.push(commissionExpense);
    }

    // 3. Frete (se houver)
    if (purchaseOrder.freightCost && purchaseOrder.freightCost > 0) {
      const freightExpense: Omit<Expense, 'id' | 'createdAt' | 'updatedAt'> = {
        description: `Frete - ${purchaseOrder.code}`,
        amount: purchaseOrder.freightCost,
        category: 'freight',
        date: purchaseOrder.purchaseDate,
        dueDate: addDays(new Date(purchaseOrder.purchaseDate), 7), // Frete geralmente pago rapidamente
        status: 'pending',
        payerAccountId: null,
        costCenter: 'ACQUISITION',
        tags: [`lote-${purchaseOrder.code}`, 'frete'],
        lotId: purchaseOrder.id,
        impactsCashFlow: true,
        isRecurring: false
      };
      expenses.push(freightExpense);
    }

    // 4. Custos adicionais (se houver)
    if (purchaseOrder.additionalCosts && purchaseOrder.additionalCosts.length > 0) {
      for (const additionalCost of purchaseOrder.additionalCosts) {
        const additionalExpense: Omit<Expense, 'id' | 'createdAt' | 'updatedAt'> = {
          description: `${additionalCost.description} - ${purchaseOrder.code}`,
          amount: additionalCost.value,
          category: 'acquisition_other',
          date: purchaseOrder.purchaseDate,
          dueDate: addDays(new Date(purchaseOrder.purchaseDate), 30),
          status: 'pending',
          payerAccountId: null,
          costCenter: 'ACQUISITION',
          tags: [`lote-${purchaseOrder.code}`, 'custo-adicional'],
          lotId: purchaseOrder.id,
          impactsCashFlow: true,
          isRecurring: false
        };
        expenses.push(additionalExpense);
      }
    }

    // Criar todas as despesas no Supabase
    for (const expense of expenses) {
      await dataService.createExpense(expense);
    }
  }

  /**
   * Cria eventos no calendário relacionados ao lote
   */
  private static async createCalendarEvents(purchaseOrder: CattlePurchase): Promise<void> {
    const events: Omit<CalendarEvent, 'id'>[] = [];

    // 1. Evento de chegada do gado
    const arrivalEvent: Omit<CalendarEvent, 'id'> = {
      title: `Chegada do Gado - ${purchaseOrder.code}`,
      description: `Chegada de ${purchaseOrder.currentQuantity} cabeças de gado do fornecedor ${purchaseOrder.vendorName}`,
      date: new Date(purchaseOrder.arrivalDate || purchaseOrder.purchaseDate),
      type: 'purchase',
      priority: 'high',
      status: 'scheduled',
      relatedId: purchaseOrder.id,
      tags: [`lote-${purchaseOrder.code}`, 'chegada-gado'],
      location: purchaseOrder.destinationLocation || 'Fazenda',
      participants: [],
      recurring: false,
      autoGenerated: true
    };
    events.push(arrivalEvent);

    // 2. Evento de pagamento (se data definida)
    if (purchaseOrder.paymentDate) {
      const paymentEvent: Omit<CalendarEvent, 'id'> = {
        title: `Pagamento - ${purchaseOrder.code}`,
        description: `Pagamento de R$ ${purchaseOrder.totalValue.toLocaleString('pt-BR', { minimumFractionDigits: 2 })} para ${purchaseOrder.vendorName}`,
        date: new Date(purchaseOrder.paymentDate),
        type: 'finance',
        priority: 'high',
        status: 'scheduled',
        relatedId: purchaseOrder.id,
        tags: [`lote-${purchaseOrder.code}`, 'pagamento'],
        participants: [],
        recurring: false,
        amount: purchaseOrder.totalValue,
        autoGenerated: true
      };
      events.push(paymentEvent);
    }

    // 3. Evento de primeira pesagem (7 dias após chegada)
    const firstWeighingDate = addDays(new Date(purchaseOrder.arrivalDate || purchaseOrder.purchaseDate), 7);
    const firstWeighingEvent: Omit<CalendarEvent, 'id'> = {
      title: `Primeira Pesagem - ${purchaseOrder.code}`,
      description: `Primeira pesagem para controle de peso do lote`,
      date: firstWeighingDate,
      type: 'general',
      priority: 'medium',
      status: 'scheduled',
      relatedId: purchaseOrder.id,
      tags: [`lote-${purchaseOrder.code}`, 'pesagem'],
      participants: [],
      recurring: false,
      autoGenerated: true
    };
    events.push(firstWeighingEvent);

    // 4. Evento de vacinação (se necessário - 15 dias após chegada)
    const vaccinationDate = addDays(new Date(purchaseOrder.arrivalDate || purchaseOrder.purchaseDate), 15);
    const vaccinationEvent: Omit<CalendarEvent, 'id'> = {
      title: `Vacinação - ${purchaseOrder.code}`,
      description: `Vacinação e cuidados veterinários do lote`,
      date: vaccinationDate,
      type: 'health',
      priority: 'high',
      status: 'scheduled',
      relatedId: purchaseOrder.id,
      tags: [`lote-${purchaseOrder.code}`, 'vacinacao', 'saude'],
      participants: [],
      recurring: false,
      autoGenerated: true
    };
    events.push(vaccinationEvent);

    // Criar todos os eventos no Supabase
    for (const event of events) {
      // Verificar se existe tabela de eventos no Supabase
      try {
        // await dataService.createCalendarEvent(event);
      } catch (error) {
        break;
      }
    }
  }

  /**
   * Cria entradas para conciliação bancária
   */
  private static async createReconciliationEntries(purchaseOrder: CattlePurchase): Promise<void> {
    // Por enquanto, apenas log - a implementação completa depende da estrutura da conciliação
    
    // Aqui seria criado um registro de transação esperada para conciliação
    // quando o pagamento for efetuado
    const expectedTransaction = {
      description: `Pagamento ${purchaseOrder.code}`,
      amount: -purchaseOrder.totalValue, // Saída de dinheiro
      expectedDate: purchaseOrder.paymentDate || addDays(new Date(purchaseOrder.purchaseDate), 30),
      type: 'expense',
      category: 'animal_purchase',
      lotId: purchaseOrder.id,
      status: 'expected'
    };
    
  }

  /**
   * Atualiza as integrações quando um lote é modificado
   */
  static async updateLotIntegrations(purchaseOrder: CattlePurchase): Promise<void> {
    
    // Aqui seria implementada a lógica para atualizar despesas, eventos, etc.
    // quando uma ordem de compra é modificada
  }

  /**
   * Remove as integrações quando um lote é excluído
   */
  static async removeLotIntegrations(purchaseId: string): Promise<void> {
    
    try {
      // Remover despesas relacionadas
      // await dataService.deleteExpensesByLotId(purchaseId);
      
      // Remover eventos relacionados
      // await dataService.deleteCalendarEventsByLotId(purchaseId);
      
    } catch (error) {
      console.error('❌ Erro ao remover integrações:', error);
      throw error;
    }
  }
}
