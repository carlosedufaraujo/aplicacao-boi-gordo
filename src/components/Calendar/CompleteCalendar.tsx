import React, { useState, useMemo, useEffect } from 'react';
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Badge } from '@/components/ui/badge';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogTrigger, DialogFooter, DialogDescription } from '@/components/ui/dialog';
import { ScrollArea } from '@/components/ui/scroll-area';
import { Separator } from '@/components/ui/separator';
import { Textarea } from '@/components/ui/textarea';
import { Popover, PopoverContent, PopoverTrigger } from '@/components/ui/popover';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
import { Switch } from '@/components/ui/switch';
import { Alert, AlertDescription } from '@/components/ui/alert';
import {
  Calendar as CalendarIcon,
  Plus,
  Filter,
  Search,
  ChevronLeft,
  ChevronRight,
  Clock,
  MapPin,
  Users,
  Package,
  Truck,
  Heart,
  DollarSign,
  AlertCircle,
  CheckCircle,
  Edit,
  Trash2,
  MoreHorizontal,
  List,
  Grid3x3,
  CalendarDays,
  Bell,
  Repeat,
  Tag,
  FileText,
  User,
  Building2,
  Stethoscope,
  ShoppingCart,
  TrendingUp,
  Beef,
  Calculator,
  Zap,
  Eye,
  Settings,
  Target,
  Activity
} from 'lucide-react';
import {
  format,
  startOfMonth,
  endOfMonth,
  startOfWeek,
  endOfWeek,
  addDays,
  addMonths,
  subMonths,
  isSameMonth,
  isSameDay,
  isToday,
  parseISO,
  eachDayOfInterval,
  getDay,
  setMonth,
  setYear,
  addWeeks,
  subWeeks,
  startOfDay,
  endOfDay,
  differenceInDays
} from 'date-fns';
import { ptBR } from 'date-fns/locale';
import { cn } from '@/lib/utils';

// Hooks da Nova Arquitetura API
import { useCattlePurchasesApi } from '@/hooks/api/useCattlePurchasesApi';
import { useExpensesApi } from '@/hooks/api/useExpensesApi';
import { useRevenuesApi } from '@/hooks/api/useRevenuesApi';
import { useCalendarEventsApi } from '@/hooks/api/useCalendarEventsApi';

interface CalendarEvent {
  id: string;
  title: string;
  description?: string;
  type: 'purchase' | 'sale' | 'health' | 'transport' | 'finance' | 'general' | 'dre' | 'payment';
  date: Date;
  time?: string;
  location?: string;
  participants?: string[];
  status?: 'scheduled' | 'in_progress' | 'completed' | 'cancelled' | 'overdue';
  priority?: 'low' | 'medium' | 'high';
  recurring?: boolean;
  tags?: string[];
  color?: string;
  relatedId?: string; // ID do registro relacionado (ordem, despesa, etc.)
  amount?: number;
  autoGenerated?: boolean; // Se foi gerado automaticamente
}

const eventTypes = [
  { id: 'purchase', label: 'Compra', icon: ShoppingCart, color: 'bg-blue-500' },
  { id: 'sale', label: 'Venda', icon: TrendingUp, color: 'bg-green-500' },
  { id: 'health', label: 'Veterinária', icon: Stethoscope, color: 'bg-red-500' },
  { id: 'transport', label: 'Transporte', icon: Truck, color: 'bg-orange-500' },
  { id: 'finance', label: 'Financeiro', icon: DollarSign, color: 'bg-purple-500' },
  { id: 'dre', label: 'DRE', icon: FileText, color: 'bg-indigo-500' },
  { id: 'payment', label: 'Pagamento', icon: Calculator, color: 'bg-yellow-500' },
  { id: 'general', label: 'Geral', icon: CalendarIcon, color: 'bg-gray-500' }
];

const priorityColors = {
  low: 'border-l-green-500',
  medium: 'border-l-yellow-500',
  high: 'border-l-red-500'
};

const statusColors = {
  scheduled: 'status-info',
  in_progress: 'status-warning',
  completed: 'status-active',
  cancelled: 'status-inactive',
  overdue: 'status-error'
};

export const CompleteCalendar: React.FC = () => {
  // Hooks da Nova Arquitetura API
  const { cattlePurchases, loading: ordersLoading } = useCattlePurchasesApi();
  const { expenses, loading: expensesLoading } = useExpensesApi();
  const { revenues, loading: revenuesLoading } = useRevenuesApi();
  const { cattlePurchases: lots, loading: lotsLoading } = useCattlePurchasesApi();
  const { 
    events: manualEvents, 
    createEvent, 
    updateEvent, 
    deleteEvent, 
    completeEvent, 
    cancelEvent,
    loading: eventsLoading 
  } = useCalendarEventsApi();

  // Estados
  const [currentDate, setCurrentDate] = useState(new Date());
  const [selectedDate, setSelectedDate] = useState<Date | null>(null);
  const [viewMode, setViewMode] = useState<'month' | 'week' | 'day' | 'list'>('month');
  const [showEventDialog, setShowEventDialog] = useState(false);
  const [selectedEvent, setSelectedEvent] = useState<CalendarEvent | null>(null);
  const [filterType, setFilterType] = useState<string>('all');
  const [searchTerm, setSearchTerm] = useState('');
  const [showNotifications, setShowNotifications] = useState(true);
  const [autoGenerateEvents, setAutoGenerateEvents] = useState(true);

  // Eventos manuais agora vêm da API através do hook

  // Gerar eventos automáticos baseados nos dados do sistema
  const autoGeneratedEvents = useMemo((): CalendarEvent[] => {
    if (!autoGenerateEvents) return [];
    
    const events: CalendarEvent[] = [];
    
    // Eventos de Ordens de Compra
    if (cattlePurchases) {
      cattlePurchases.forEach(order => {
        // Evento de entrega prevista
        if (order.expectedDeliveryDate) {
          events.push({
            id: `order-delivery-${order.id}`,
            title: `Entrega: ${order.lotCode}`,
            description: `Entrega prevista de ${order.animalCount} animais`,
            type: 'purchase',
            date: new Date(order.expectedDeliveryDate),
            status: new Date(order.expectedDeliveryDate) < new Date() ? 'overdue' : 'scheduled',
            priority: 'high',
            relatedId: order.id,
            autoGenerated: true,
            amount: order.totalValue
          });
        }
        
        // Evento de pagamento
        if (order.paymentDueDate) {
          events.push({
            id: `order-payment-${order.id}`,
            title: `Pagamento: ${order.lotCode}`,
            description: `Vencimento do pagamento`,
            type: 'payment',
            date: new Date(order.paymentDueDate),
            status: new Date(order.paymentDueDate) < new Date() ? 'overdue' : 'scheduled',
            priority: 'high',
            relatedId: order.id,
            autoGenerated: true,
            amount: order.totalValue
          });
        }
      });
    }
    
    // Eventos de Despesas (vencimentos)
    if (expenses) {
      expenses.forEach(expense => {
        if (expense.dueDate && !expense.isPaid) {
          events.push({
            id: `expense-${expense.id}`,
            title: `Vencimento: ${expense.description}`,
            description: `Despesa de ${expense.category}`,
            type: 'finance',
            date: new Date(expense.dueDate),
            status: new Date(expense.dueDate) < new Date() ? 'overdue' : 'scheduled',
            priority: new Date(expense.dueDate) < addDays(new Date(), 3) ? 'high' : 'medium',
            relatedId: expense.id,
            autoGenerated: true,
            amount: expense.purchaseValue
          });
        }
      });
    }
    
    // Eventos de Receitas (recebimentos previstos)
    if (revenues) {
      revenues.forEach(revenue => {
        if (revenue.expectedDate && !revenue.isReceived) {
          events.push({
            id: `revenue-${revenue.id}`,
            title: `Recebimento: ${revenue.description}`,
            description: `Receita de ${revenue.category}`,
            type: 'finance',
            date: new Date(revenue.expectedDate),
            status: 'scheduled',
            priority: 'medium',
            relatedId: revenue.id,
            autoGenerated: true,
            amount: revenue.purchaseValue
          });
        }
      });
    }
    
    // Eventos de Lotes (atividades veterinárias programadas)
    if (cattlePurchases) {
      cattlePurchases.forEach(lot => {
        // Verificação veterinária mensal
        const lastCheck = lot.lastHealthCheck ? new Date(lot.lastHealthCheck) : new Date(lot.entryDate);
        const nextCheck = addDays(lastCheck, 30);
        
        if (nextCheck > new Date() && differenceInDays(nextCheck, new Date()) <= 60) {
          events.push({
            id: `health-check-${lot.id}`,
            title: `Verificação Veterinária: Lote ${lot.lotNumber}`,
            description: `Verificação mensal de saúde - ${lot.animalCount} animais`,
            type: 'health',
            date: nextCheck,
            status: 'scheduled',
            priority: 'medium',
            relatedId: lot.id,
            autoGenerated: true
          });
        }
      });
    }
    
    // Eventos de DRE (geração mensal)
    const today = new Date();
    const nextMonth = addMonths(startOfMonth(today), 1);
    const dreDate = new Date(nextMonth.getFullYear(), nextMonth.getMonth(), 5); // Dia 5 do próximo mês
    
    events.push({
      id: 'dre-monthly',
      title: 'Geração DRE Mensal',
      description: 'Gerar demonstrativo de resultados do mês',
      type: 'dre',
      date: dreDate,
      status: 'scheduled',
      priority: 'high',
      autoGenerated: true,
      recurring: true
    });
    
    return events;
  }, [cattlePurchases, expenses, revenues, cattlePurchases, autoGenerateEvents]);

  // Combinar eventos manuais e automáticos
  const allEvents = useMemo(() => {
    return [...manualEvents, ...autoGeneratedEvents];
  }, [manualEvents, autoGeneratedEvents]);

  // Filtrar eventos
  const filteredEvents = useMemo(() => {
    return allEvents.filter(event => {
      if (filterType !== 'all' && event.type !== filterType) {
        return false;
      }
      if (searchTerm && !event.title.toLowerCase().includes(searchTerm.toLowerCase())) {
        return false;
      }
      return true;
    });
  }, [allEvents, filterType, searchTerm]);

  // Eventos por data
  const eventsByDate = useMemo(() => {
    const grouped: Record<string, CalendarEvent[]> = {};
    
    filteredEvents.forEach(event => {
      const dateKey = format(event.date, 'yyyy-MM-dd');
      if (!grouped[dateKey]) {
        grouped[dateKey] = [];
      }
      grouped[dateKey].push(event);
    });
    
    return grouped;
  }, [filteredEvents]);

  // Calcular estatísticas
  const stats = useMemo(() => {
    const today = new Date();
    const thisMonth = startOfMonth(today);
    const nextMonth = endOfMonth(today);
    
    const eventsThisMonth = filteredEvents.filter(event => 
      event.date >= thisMonth && event.date <= nextMonth
    );
    
    const overdueEvents = filteredEvents.filter(event => 
      event.date < today && event.status !== 'completed' && event.status !== 'cancelled'
    );
    
    const upcomingEvents = filteredEvents.filter(event => 
      event.date >= today && event.date <= addDays(today, 7)
    );
    
    const highPriorityEvents = filteredEvents.filter(event => 
      event.priority === 'high' && event.status === 'scheduled'
    );
    
    return {
      totalEvents: filteredEvents.length,
      thisMonth: eventsThisMonth.length,
      overdue: overdueEvents.length,
      upcoming: upcomingEvents.length,
      highPriority: highPriorityEvents.length
    };
  }, [filteredEvents]);

  // Gerar dias do calendário
  const calendarDays = useMemo(() => {
    const start = startOfWeek(startOfMonth(currentDate));
    const end = endOfWeek(endOfMonth(currentDate));
    
    return eachDayOfInterval({ start, end });
  }, [currentDate]);

  const handleEventClick = (event: CalendarEvent) => {
    setSelectedEvent(event);
    setShowEventDialog(true);
  };

  const handleDateClick = (date: Date) => {
    setSelectedDate(date);
  };

  const handleCreateEvent = async (eventData: any) => {
    try {
      await createEvent({
        title: eventData.title,
        description: eventData.description,
        type: eventData.type,
        date: eventData.date,
        time: eventData.time,
        location: eventData.location,
        participants: eventData.participants,
        priority: eventData.priority,
        tags: eventData.tags,
        color: eventData.color,
        amount: eventData.amount,
        cycleId: eventData.cycleId
      });
      setShowEventDialog(false);
      setSelectedEvent(null);
    } catch (error) {
      console.error('Erro ao criar evento:', error);
    }
  };

  const navigateMonth = (direction: 'prev' | 'next') => {
    setCurrentDate(prev => 
      direction === 'prev' ? subMonths(prev, 1) : addMonths(prev, 1)
    );
  };

  const navigateWeek = (direction: 'prev' | 'next') => {
    setCurrentDate(prev => 
      direction === 'prev' ? subWeeks(prev, 1) : addWeeks(prev, 1)
    );
  };

  const getEventsForDate = (date: Date) => {
    const dateKey = format(date, 'yyyy-MM-dd');
    return eventsByDate[dateKey] || [];
  };

  if (ordersLoading || expensesLoading || revenuesLoading || lotsLoading || eventsLoading) {
    return (
      <div className="flex items-center justify-center h-64">
        <div className="flex flex-col items-center space-y-4">
          <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-primary"></div>
          <p className="text-sm text-muted-foreground">Carregando calendário...</p>
        </div>
      </div>
    );
  }

  return (
    <div className="space-y-6">
      {/* Header */}
      <div className="flex flex-col lg:flex-row lg:items-center lg:justify-between gap-4">
        <div>
          <h1 className="page-title">Calendário Financeiro</h1>
          <p className="page-subtitle">
            Acompanhe eventos, vencimentos e atividades programadas
          </p>
        </div>
        
        <div className="flex items-center gap-2">
          <Button 
            variant="outline"
            onClick={() => setShowNotifications(!showNotifications)}
            className="flex items-center gap-2"
          >
            <Bell className={cn("h-4 w-4", showNotifications && "text-primary")} />
            Notificações
          </Button>
          <Button 
            onClick={() => setShowEventDialog(true)}
            className="flex items-center gap-2"
          >
            <Plus className="h-4 w-4" />
            Novo Evento
          </Button>
        </div>
      </div>

      {/* KPIs */}
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-5 gap-4">
        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="kpi-label">Total de Eventos</CardTitle>
            <CalendarIcon className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="kpi-value">{stats.totalEvents}</div>
            <p className="kpi-change">
              <Activity className="h-3 w-3" />
              eventos cadastrados
            </p>
          </CardContent>
        </Card>

        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="kpi-label">Este Mês</CardTitle>
            <CalendarDays className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="kpi-value">{stats.thisMonth}</div>
            <p className="kpi-change">
              <TrendingUp className="h-3 w-3" />
              eventos programados
            </p>
          </CardContent>
        </Card>

        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="kpi-label">Próximos 7 Dias</CardTitle>
            <Clock className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="kpi-value">{stats.upcoming}</div>
            <p className="kpi-change">
              <Target className="h-3 w-3" />
              eventos próximos
            </p>
          </CardContent>
        </Card>

        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="kpi-label">Em Atraso</CardTitle>
            <AlertCircle className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="kpi-value text-red-600">{stats.overdue}</div>
            <p className="kpi-change text-red-600">
              <AlertCircle className="h-3 w-3" />
              eventos atrasados
            </p>
          </CardContent>
        </Card>

        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="kpi-label">Alta Prioridade</CardTitle>
            <Zap className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="kpi-value text-orange-600">{stats.highPriority}</div>
            <p className="kpi-change text-orange-600">
              <Zap className="h-3 w-3" />
              eventos urgentes
            </p>
          </CardContent>
        </Card>
      </div>

      {/* Notificações */}
      {showNotifications && stats.overdue > 0 && (
        <Alert className="border-red-200 bg-red-50">
          <AlertCircle className="h-4 w-4 text-red-600" />
          <AlertDescription className="text-red-800">
            <strong>Atenção!</strong> Você tem {stats.overdue} evento(s) em atraso que precisam de atenção.
          </AlertDescription>
        </Alert>
      )}

      {/* Controles e Filtros */}
      <Card>
        <CardContent className="pt-6">
          <div className="flex flex-col lg:flex-row gap-4">
            {/* Navegação */}
            <div className="flex items-center gap-2">
              <Button 
                variant="outline" 
                size="sm"
                onClick={() => viewMode === 'month' ? navigateMonth('prev') : navigateWeek('prev')}
              >
                <ChevronLeft className="h-4 w-4" />
              </Button>
              <div className="min-w-[200px] text-center">
                <h3 className="font-semibold">
                  {format(currentDate, 'MMMM yyyy', { locale: ptBR })}
                </h3>
              </div>
              <Button 
                variant="outline" 
                size="sm"
                onClick={() => viewMode === 'month' ? navigateMonth('next') : navigateWeek('next')}
              >
                <ChevronRight className="h-4 w-4" />
              </Button>
            </div>

            {/* Modo de Visualização */}
            <div className="flex items-center gap-1 border rounded-lg p-1">
              {[
                { id: 'month', label: 'Mês', icon: Grid3x3 },
                { id: 'week', label: 'Semana', icon: CalendarDays },
                { id: 'list', label: 'Lista', icon: List }
              ].map(mode => (
                <Button
                  key={mode.id}
                  variant={viewMode === mode.id ? 'default' : 'ghost'}
                  size="sm"
                  onClick={() => setViewMode(mode.id as any)}
                  className="flex items-center gap-1"
                >
                  <mode.icon className="h-3 w-3" />
                  {mode.label}
                </Button>
              ))}
            </div>

            {/* Busca */}
            <div className="flex-1">
              <div className="relative">
                <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 h-4 w-4 text-muted-foreground" />
                <Input
                  placeholder="Buscar eventos..."
                  value={searchTerm}
                  onChange={(e) => setSearchTerm(e.target.value)}
                  className="pl-9"
                />
              </div>
            </div>
            
            {/* Filtro por Tipo */}
            <Select value={filterType} onValueChange={setFilterType}>
              <SelectTrigger className="w-full lg:w-[200px]">
                <SelectValue placeholder="Filtrar por tipo" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="all">Todos os Tipos</SelectItem>
                {eventTypes.map(type => (
                  <SelectItem key={type.id} value={type.id}>
                    {type.label}
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>

            {/* Configurações */}
            <Popover>
              <PopoverTrigger asChild>
                <Button variant="outline" size="sm">
                  <Settings className="h-4 w-4" />
                </Button>
              </PopoverTrigger>
              <PopoverContent className="w-80">
                <div className="space-y-4">
                  <h4 className="font-medium">Configurações do Calendário</h4>
                  
                  <div className="flex items-center justify-between">
                    <Label htmlFor="auto-events">Eventos Automáticos</Label>
                    <Switch
                      id="auto-events"
                      checked={autoGenerateEvents}
                      onCheckedChange={setAutoGenerateEvents}
                    />
                  </div>
                  
                  <div className="flex items-center justify-between">
                    <Label htmlFor="notifications">Notificações</Label>
                    <Switch
                      id="notifications"
                      checked={showNotifications}
                      onCheckedChange={setShowNotifications}
                    />
                  </div>
                  
                  <Separator />
                  
                  <div className="text-xs text-muted-foreground">
                    <p>• Eventos automáticos são gerados baseados em ordens de compra, despesas e receitas</p>
                    <p>• Notificações alertam sobre eventos em atraso ou próximos</p>
                  </div>
                </div>
              </PopoverContent>
            </Popover>
          </div>
        </CardContent>
      </Card>

      {/* Calendário */}
      <Tabs value={viewMode} onValueChange={(value) => setViewMode(value as any)}>
        <TabsContent value="month" className="space-y-4">
          <Card>
            <CardContent className="p-6">
              {/* Cabeçalho dos dias da semana */}
              <div className="grid grid-cols-7 gap-1 mb-4">
                {['Dom', 'Seg', 'Ter', 'Qua', 'Qui', 'Sex', 'Sáb'].map(day => (
                  <div key={day} className="p-2 text-center text-sm font-medium text-muted-foreground">
                    {day}
                  </div>
                ))}
              </div>
              
              {/* Dias do calendário */}
              <div className="grid grid-cols-7 gap-1">
                {calendarDays.map(day => {
                  const dayEvents = getEventsForDate(day);
                  const isCurrentMonth = isSameMonth(day, currentDate);
                  const isSelected = selectedDate && isSameDay(day, selectedDate);
                  const isToday = isSameDay(day, new Date());
                  
                  return (
                    <div
                      key={day.toISOString()}
                      className={cn(
                        "min-h-[100px] p-2 border border-border rounded-lg cursor-pointer hover:bg-muted/50 transition-colors",
                        !isCurrentMonth && "text-muted-foreground bg-muted/20",
                        isSelected && "ring-2 ring-primary",
                        isToday && "bg-primary/10 border-primary"
                      )}
                      onClick={() => handleDateClick(day)}
                    >
                      <div className="flex justify-between items-start mb-1">
                        <span className={cn(
                          "text-sm font-medium",
                          isToday && "text-primary font-bold"
                        )}>
                          {format(day, 'd')}
                        </span>
                        {dayEvents.length > 0 && (
                          <Badge variant="secondary" className="text-xs">
                            {dayEvents.length}
                          </Badge>
                        )}
                      </div>
                      
                      <div className="space-y-1">
                        {dayEvents.slice(0, 3).map(event => {
                          const eventType = eventTypes.find(t => t.id === event.type);
                          return (
                            <div
                              key={event.id}
                              className={cn(
                                "text-xs p-1 rounded border-l-2 bg-muted/50 cursor-pointer hover:bg-muted",
                                priorityColors[event.priority || 'medium'],
                                event.status === 'overdue' && "bg-red-50 text-red-700"
                              )}
                              onClick={(e) => {
                                e.stopPropagation();
                                handleEventClick(event);
                              }}
                            >
                              <div className="flex items-center gap-1">
                                {eventType && <eventType.icon className="h-3 w-3" />}
                                <span className="truncate">{event.title}</span>
                              </div>
                              {event.time && (
                                <div className="text-xs text-muted-foreground">
                                  {event.time}
                                </div>
                              )}
                            </div>
                          );
                        })}
                        {dayEvents.length > 3 && (
                          <div className="text-xs text-muted-foreground text-center">
                            +{dayEvents.length - 3} mais
                          </div>
                        )}
                      </div>
                    </div>
                  );
                })}
              </div>
            </CardContent>
          </Card>
        </TabsContent>

        <TabsContent value="list" className="space-y-4">
          <Card>
            <CardHeader>
              <CardTitle>Lista de Eventos</CardTitle>
              <CardDescription>
                Todos os eventos organizados por data
              </CardDescription>
            </CardHeader>
            <CardContent>
              <ScrollArea className="h-[600px]">
                <div className="space-y-4">
                  {Object.entries(eventsByDate)
                    .sort(([a], [b]) => a.localeCompare(b))
                    .map(([dateKey, events]) => (
                      <div key={dateKey} className="space-y-2">
                        <h4 className="font-medium text-sm text-muted-foreground border-b pb-1">
                          {format(new Date(dateKey), 'EEEE, dd \'de\' MMMM', { locale: ptBR })}
                        </h4>
                        <div className="space-y-2 ml-4">
                          {events.map(event => {
                            const eventType = eventTypes.find(t => t.id === event.type);
                            return (
                              <Card 
                                key={event.id} 
                                className={cn(
                                  "cursor-pointer hover:shadow-md transition-shadow border-l-4",
                                  priorityColors[event.priority || 'medium'],
                                  event.status === 'overdue' && "bg-red-50"
                                )}
                                onClick={() => handleEventClick(event)}
                              >
                                <CardContent className="p-4">
                                  <div className="flex items-start justify-between">
                                    <div className="flex items-start gap-3">
                                      {eventType && (
                                        <div className={cn("p-2 rounded-lg", eventType.color)}>
                                          <eventType.icon className="h-4 w-4 text-white" />
                                        </div>
                                      )}
                                      <div>
                                        <h5 className="font-medium">{event.title}</h5>
                                        {event.description && (
                                          <p className="text-sm text-muted-foreground">
                                            {event.description}
                                          </p>
                                        )}
                                        <div className="flex items-center gap-4 mt-2 text-xs text-muted-foreground">
                                          {event.time && (
                                            <span className="flex items-center gap-1">
                                              <Clock className="h-3 w-3" />
                                              {event.time}
                                            </span>
                                          )}
                                          {event.amount && (
                                            <span className="flex items-center gap-1">
                                              <DollarSign className="h-3 w-3" />
                                              R$ {event.amount.toLocaleString('pt-BR', { minimumFractionDigits: 2 })}
                                            </span>
                                          )}
                                          {event.autoGenerated && (
                                            <Badge variant="outline" className="text-xs">
                                              <Zap className="h-2 w-2 mr-1" />
                                              Auto
                                            </Badge>
                                          )}
                                        </div>
                                      </div>
                                    </div>
                                    <Badge className={statusColors[event.status || 'scheduled']}>
                                      {event.status === 'scheduled' && 'Agendado'}
                                      {event.status === 'in_progress' && 'Em Andamento'}
                                      {event.status === 'completed' && 'Concluído'}
                                      {event.status === 'cancelled' && 'Cancelado'}
                                      {event.status === 'overdue' && 'Atrasado'}
                                    </Badge>
                                  </div>
                                </CardContent>
                              </Card>
                            );
                          })}
                        </div>
                      </div>
                    ))}
                </div>
              </ScrollArea>
            </CardContent>
          </Card>
        </TabsContent>
      </Tabs>

      {/* Dialog de Detalhes do Evento */}
      <Dialog open={showEventDialog} onOpenChange={setShowEventDialog}>
        <DialogContent className="max-w-2xl">
          <DialogHeader>
            <DialogTitle>
              {selectedEvent ? 'Detalhes do Evento' : 'Novo Evento'}
            </DialogTitle>
            <DialogDescription>
              {selectedEvent ? 'Informações completas do evento' : 'Criar um novo evento no calendário'}
            </DialogDescription>
          </DialogHeader>
          
          {selectedEvent ? (
            <div className="space-y-4">
              <div className="grid grid-cols-2 gap-4">
                <div>
                  <Label className="text-sm font-medium">Título</Label>
                  <p className="text-sm">{selectedEvent.title}</p>
                </div>
                <div>
                  <Label className="text-sm font-medium">Tipo</Label>
                  <div className="flex items-center gap-2">
                    {(() => {
                      const eventType = eventTypes.find(t => t.id === selectedEvent.type);
                      return eventType ? (
                        <>
                          <eventType.icon className="h-4 w-4" />
                          <span className="text-sm">{eventType.label}</span>
                        </>
                      ) : null;
                    })()}
                  </div>
                </div>
                <div>
                  <Label className="text-sm font-medium">Data</Label>
                  <p className="text-sm">
                    {format(selectedEvent.date, 'dd/MM/yyyy', { locale: ptBR })}
                  </p>
                </div>
                <div>
                  <Label className="text-sm font-medium">Horário</Label>
                  <p className="text-sm">{selectedEvent.time || 'Não definido'}</p>
                </div>
                <div>
                  <Label className="text-sm font-medium">Status</Label>
                  <Badge className={statusColors[selectedEvent.status || 'scheduled']}>
                    {selectedEvent.status === 'scheduled' && 'Agendado'}
                    {selectedEvent.status === 'in_progress' && 'Em Andamento'}
                    {selectedEvent.status === 'completed' && 'Concluído'}
                    {selectedEvent.status === 'cancelled' && 'Cancelado'}
                    {selectedEvent.status === 'overdue' && 'Atrasado'}
                  </Badge>
                </div>
                <div>
                  <Label className="text-sm font-medium">Prioridade</Label>
                  <Badge variant="outline">
                    {selectedEvent.priority === 'high' && 'Alta'}
                    {selectedEvent.priority === 'medium' && 'Média'}
                    {selectedEvent.priority === 'low' && 'Baixa'}
                  </Badge>
                </div>
              </div>
              
              {selectedEvent.description && (
                <div>
                  <Label className="text-sm font-medium">Descrição</Label>
                  <p className="text-sm text-muted-foreground">{selectedEvent.description}</p>
                </div>
              )}
              
              {selectedEvent.amount && (
                <div>
                  <Label className="text-sm font-medium">Valor</Label>
                  <p className="text-sm font-medium">
                    R$ {selectedEvent.amount.toLocaleString('pt-BR', { minimumFractionDigits: 2 })}
                  </p>
                </div>
              )}
              
              {selectedEvent.autoGenerated && (
                <Alert>
                  <Zap className="h-4 w-4" />
                  <AlertDescription>
                    Este evento foi gerado automaticamente baseado nos dados do sistema.
                    {selectedEvent.relatedId && ' Clique em "Ver Origem" para acessar o registro relacionado.'}
                  </AlertDescription>
                </Alert>
              )}
            </div>
          ) : (
            <EventForm 
              selectedDate={selectedDate}
              onSubmit={handleCreateEvent}
              onClose={() => setShowEventDialog(false)}
            />
          )}
          
          <DialogFooter>
            <Button variant="outline" onClick={() => setShowEventDialog(false)}>
              Fechar
            </Button>
            {selectedEvent?.relatedId && (
              <Button variant="outline">
                <Eye className="h-4 w-4 mr-2" />
                Ver Origem
              </Button>
            )}
            {selectedEvent && !selectedEvent.autoGenerated && (
              <Button>
                <Edit className="h-4 w-4 mr-2" />
                Editar
              </Button>
            )}
          </DialogFooter>
        </DialogContent>
      </Dialog>
    </div>
  );
};

// Componente de formulário de eventos
const EventForm: React.FC<{
  selectedDate: Date | null;
  onSubmit: (data: any) => void;
  onClose: () => void;
}> = ({ selectedDate, onSubmit, onClose }) => {
  const [formData, setFormData] = useState({
    title: '',
    description: '',
    type: 'GENERAL',
    date: selectedDate || new Date(),
    time: '',
    location: '',
    participants: [] as string[],
    priority: 'MEDIUM',
    tags: [] as string[],
    color: '#3b82f6',
    amount: '',
    cycleId: ''
  });

  const eventTypes = [
    { value: 'GENERAL', label: 'Geral' },
    { value: 'FINANCE', label: 'Financeiro' },
    { value: 'PURCHASE', label: 'Compra' },
    { value: 'SALE', label: 'Venda' },
    { value: 'HEALTH', label: 'Veterinário' },
    { value: 'TRANSPORT', label: 'Transporte' },
    { value: 'MEETING', label: 'Reunião' },
    { value: 'TASK', label: 'Tarefa' }
  ];

  const priorities = [
    { value: 'LOW', label: 'Baixa' },
    { value: 'MEDIUM', label: 'Média' },
    { value: 'HIGH', label: 'Alta' },
    { value: 'URGENT', label: 'Urgente' }
  ];

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    onSubmit({
      ...formData,
      date: new Date(formData.date),
      amount: formData.amount ? parseFloat(formData.amount) : undefined
    });
  };

  const handleChange = (field: string, value: any) => {
    setFormData(prev => ({
      ...prev,
      [field]: value
    }));
  };

  return (
    <form onSubmit={handleSubmit} className="space-y-4">
      <div className="grid grid-cols-2 gap-4">
        <div>
          <Label htmlFor="title">Título *</Label>
          <Input
            id="title"
            value={formData.title}
            onChange={(e) => handleChange('title', e.target.value)}
            required
          />
        </div>
        <div>
          <Label htmlFor="type">Tipo</Label>
          <Select value={formData.type} onValueChange={(value) => handleChange('type', value)}>
            <SelectTrigger>
              <SelectValue />
            </SelectTrigger>
            <SelectContent>
              {eventTypes.map(type => (
                <SelectItem key={type.value} value={type.value}>
                  {type.label}
                </SelectItem>
              ))}
            </SelectContent>
          </Select>
        </div>
      </div>

      <div>
        <Label htmlFor="description">Descrição</Label>
        <Textarea
          id="description"
          value={formData.description}
          onChange={(e) => handleChange('description', e.target.value)}
          rows={3}
        />
      </div>

      <div className="grid grid-cols-3 gap-4">
        <div>
          <Label htmlFor="date">Data *</Label>
          <Input
            id="date"
            type="date"
            value={format(new Date(formData.date), 'yyyy-MM-dd')}
            onChange={(e) => handleChange('date', e.target.value)}
            required
          />
        </div>
        <div>
          <Label htmlFor="time">Horário</Label>
          <Input
            id="time"
            type="time"
            value={formData.time}
            onChange={(e) => handleChange('time', e.target.value)}
          />
        </div>
        <div>
          <Label htmlFor="priority">Prioridade</Label>
          <Select value={formData.priority} onValueChange={(value) => handleChange('priority', value)}>
            <SelectTrigger>
              <SelectValue />
            </SelectTrigger>
            <SelectContent>
              {priorities.map(priority => (
                <SelectItem key={priority.value} value={priority.value}>
                  {priority.label}
                </SelectItem>
              ))}
            </SelectContent>
          </Select>
        </div>
      </div>

      <div className="grid grid-cols-2 gap-4">
        <div>
          <Label htmlFor="location">Local</Label>
          <Input
            id="location"
            value={formData.location}
            onChange={(e) => handleChange('location', e.target.value)}
            placeholder="Ex: Escritório, Curral 1, etc."
          />
        </div>
        <div>
          <Label htmlFor="amount">Valor (R$)</Label>
          <Input
            id="amount"
            type="number"
            step="0.01"
            value={formData.amount}
            onChange={(e) => handleChange('amount', e.target.value)}
            placeholder="0,00"
          />
        </div>
      </div>

      <div className="flex justify-end space-x-2 pt-4">
        <Button type="button" variant="outline" onClick={onClose}>
          Cancelar
        </Button>
        <Button type="submit">
          <Plus className="h-4 w-4 mr-2" />
          Criar Evento
        </Button>
      </div>
    </form>
  );
};
