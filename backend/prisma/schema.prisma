generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id              String           @id @default(uuid()) @db.Uuid
  email           String           @unique
  password        String
  name            String?
  role            String?          @default("USER")
  isMaster        Boolean?         @default(false)
  isActive        Boolean?         @default(true)
  createdAt       DateTime?        @default(now()) @db.Timestamptz(6)
  updatedAt       DateTime?        @default(now()) @updatedAt @db.Timestamptz(6)
  // New CattlePurchase relation
  cattlePurchases CattlePurchase[]

  @@map("users")
}

model Partner {
  id                     String                  @id @default(cuid())
  name                   String
  type                   PartnerType
  cpfCnpj                String?                 @unique
  phone                  String?
  email                  String?
  address                String?
  notes                  String?
  isActive               Boolean                 @default(true)
  createdAt              DateTime                @default(now())
  updatedAt              DateTime                @updatedAt
  contributions          FinancialContribution[]
  saleRecords            SaleRecord[]
  // New CattlePurchase relations
  purchasesAsVendor      CattlePurchase[]        @relation("PurchaseVendor")
  purchasesAsBroker      CattlePurchase[]        @relation("PurchaseBroker")
  purchasesAsTransport   CattlePurchase[]        @relation("PurchaseTransport")

  @@map("partners")
}

model PayerAccount {
  id              String                    @id @default(cuid())
  bankName        String
  accountName     String
  agency          String?
  accountNumber   String?
  accountType     AccountType
  balance         Float                     @default(0)
  isActive        Boolean                   @default(true)
  createdAt       DateTime                  @default(now())
  updatedAt       DateTime                  @updatedAt
  bankStatements  BankStatement[]
  expenses        Expense[]
  contributions   FinancialContribution[]
  reconciliations FinancialReconciliation[]
  revenues        Revenue[]
  // New CattlePurchase relation
  cattlePurchases CattlePurchase[]

  @@map("payer_accounts")
}

// Tabela unificada para Lotes de Gado
model CattlePurchase {
  id      String @id @default(cuid())
  // Código único de identificação
  lotCode      String  @unique // Ex: LOT-2501001 (ano+mês+sequencial)

  // Relacionamentos principais
  vendorId           String
  brokerId           String?
  transportCompanyId String?
  payerAccountId     String
  userId             String?   @db.Uuid

  // Localização e data
  location     String?
  city         String?
  state        String?
  farm         String?
  purchaseDate DateTime
  receivedDate DateTime? // Data de recepção no confinamento

  // Informações dos animais
  animalType      AnimalType @default(MALE)
  animalAge       Float? // Idade média em meses
  initialQuantity Int // Quantidade comprada
  currentQuantity Int // Quantidade atual (após mortes)
  deathCount      Int        @default(0)

  // Pesos
  purchaseWeight        Float // Peso total na compra
  receivedWeight        Float? // Peso real na recepção
  currentWeight         Float? // Peso atual estimado
  averageWeight         Float? // Peso médio por animal
  weightBreakPercentage Float? // Quebra de peso no transporte

  // Valores e rendimento
  carcassYield   Float @default(50) // Rendimento de carcaça %
  pricePerArroba Float // Preço por arroba
  purchaseValue  Float // Valor da compra (calculado)

  // Custos adicionais
  freightCost      Float  @default(0)
  freightDistance  Float? // Distância em km
  freightCostPerKm Float? // Custo por km
  commission       Float  @default(0)
  healthCost       Float  @default(0)
  feedCost         Float  @default(0)
  operationalCost  Float  @default(0)
  totalCost        Float // Custo total acumulado

  // Informações de pagamento
  paymentType           PaymentType @default(CASH)
  paymentTerms          String?
  principalDueDate      DateTime?
  commissionPaymentType String? // cash ou installment
  commissionDueDate     DateTime?
  freightPaymentType    String? // cash ou installment
  freightDueDate        DateTime?

  // GMD e projeções
  expectedGMD            Float? // Ganho Médio Diário esperado (kg/dia)
  targetWeight           Float? // Peso alvo de abate (kg)
  estimatedSlaughterDate DateTime? // Data estimada de abate

  // Status e controle
  status PurchaseStatus @default(CONFIRMED)
  stage  String? // Estágio detalhado do processo
  notes  String?
  
  // Ciclo
  cycleId String?
  cycle   Cycle?  @relation(fields: [cycleId], references: [id])

  // Mortalidade no transporte
  transportMortality Int? @default(0)

  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relacionamentos
  vendor           Partner      @relation("PurchaseVendor", fields: [vendorId], references: [id])
  broker           Partner?     @relation("PurchaseBroker", fields: [brokerId], references: [id])
  transportCompany Partner?     @relation("PurchaseTransport", fields: [transportCompanyId], references: [id])
  payerAccount     PayerAccount @relation(fields: [payerAccountId], references: [id])
  user             User?        @relation(fields: [userId], references: [id])

  // Relacionamentos com outras tabelas
  penAllocations    LotPenLink[]
  healthRecords     HealthRecord[]
  movements         LotMovement[]
  weightReadings    WeightReading[]
  saleRecords       SaleRecord[]
  expenses          Expense[]
  financialAccounts FinancialAccount[]
  costAllocations   CostProportionalAllocation[]
  nonCashExpenses   NonCashExpense[]

  @@map("cattle_purchases")
}

// Enum para status da compra unificado
enum PurchaseStatus {
  CONFIRMED   // Compra confirmada
  IN_TRANSIT  // Em trânsito
  ACTIVE      // Em confinamento ativo (recepcionado e alocado)
  SOLD        // Vendido
  CANCELLED   // Cancelado
}

model Pen {
  id              String           @id @default(cuid())
  penNumber       String           @unique
  capacity        Int
  location        String?
  type            PenType          @default(FATTENING)
  status          PenStatus        @default(AVAILABLE)
  isActive        Boolean          @default(true)
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt
  feedRecords     FeedRecord[]
  healthProtocols HealthProtocol[]
  lotAllocations  LotPenLink[]

  @@map("pens")
}

model LotPenLink {
  id              String         @id @default(cuid())
  purchaseId      String
  penId           String
  quantity        Int
  percentageOfLot Float
  percentageOfPen Float
  allocationDate  DateTime
  removalDate     DateTime?
  status          LinkStatus     @default(ACTIVE)
  createdAt       DateTime       @default(now())
  updatedAt       DateTime       @updatedAt
  purchase        CattlePurchase @relation(fields: [purchaseId], references: [id])
  pen             Pen            @relation(fields: [penId], references: [id])

  @@unique([purchaseId, penId, allocationDate])
  @@map("lot_pen_links")
}

model CostProportionalAllocation {
  id                  String         @id @default(cuid())
  sourceId            String
  sourceType          CostSourceType
  penId               String
  purchaseId          String
  originalValue       Float
  allocatedValue      Float
  allocatedPercentage Float
  allocationDate      DateTime
  createdAt           DateTime       @default(now())
  purchase            CattlePurchase @relation(fields: [purchaseId], references: [id])

  @@map("cost_proportional_allocations")
}

model HealthProtocol {
  id              String         @id @default(cuid())
  name            String
  type            ProtocolType
  penId           String
  applicationDate DateTime
  veterinarian    String?
  totalCost       Float
  notes           String?
  createdAt       DateTime       @default(now())
  updatedAt       DateTime       @updatedAt
  pen             Pen            @relation(fields: [penId], references: [id])
  healthRecords   HealthRecord[]

  @@map("health_protocols")
}

model HealthRecord {
  id            String         @id @default(cuid())
  protocolId    String
  purchaseId    String
  animalCount   Int
  costPerAnimal Float
  totalCost     Float
  userId        String
  createdAt     DateTime       @default(now())
  purchase      CattlePurchase @relation(fields: [purchaseId], references: [id])
  protocol      HealthProtocol @relation(fields: [protocolId], references: [id])

  @@map("health_records")
}

model FeedRecord {
  id        String   @id @default(cuid())
  penId     String
  feedDate  DateTime
  feedType  String
  quantity  Float
  unitCost  Float
  totalCost Float
  notes     String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  pen       Pen      @relation(fields: [penId], references: [id])

  @@map("feed_records")
}

model LotMovement {
  id           String         @id @default(cuid())
  purchaseId   String
  fromPenId    String?
  toPenId      String?
  movementType MovementType
  quantity     Int
  reason       String?
  userId       String
  movementDate DateTime
  createdAt    DateTime       @default(now())
  purchase     CattlePurchase @relation(fields: [purchaseId], references: [id])

  @@map("lot_movements")
}

model WeightReading {
  id            String         @id @default(cuid())
  purchaseId    String
  readingDate   DateTime
  averageWeight Float
  totalWeight   Float
  animalCount   Int
  userId        String
  notes         String?
  createdAt     DateTime       @default(now())
  purchase      CattlePurchase @relation(fields: [purchaseId], references: [id])

  @@map("weight_readings")
}

model SaleRecord {
  id               String         @id @default(cuid())
  saleNumber       String         @unique
  purchaseId       String
  buyerId          String
  cycleId          String?
  designationDate  DateTime
  slaughterPlant   String
  expectedDate     DateTime
  shipmentDate     DateTime?
  shipmentWeight   Float?
  transportCompany String?
  slaughterDate    DateTime?
  slaughterWeight  Float?
  carcassYield     Float?
  pricePerArroba   Float?
  totalValue       Float?
  invoiceNumber    String?
  paymentDate      DateTime?
  status           SaleStatus     @default(NEXT_SLAUGHTER)
  userId           String
  notes            String?
  createdAt        DateTime       @default(now())
  updatedAt        DateTime       @updatedAt
  buyer            Partner        @relation(fields: [buyerId], references: [id])
  purchase         CattlePurchase @relation(fields: [purchaseId], references: [id])
  cycle            Cycle?         @relation(fields: [cycleId], references: [id])

  @@map("sale_records")
}

model CostCenter {
  id        String         @id @default(cuid())
  code      String         @unique
  name      String
  type      CostCenterType
  parentId  String?
  isActive  Boolean        @default(true)
  createdAt DateTime       @default(now())
  updatedAt DateTime       @updatedAt
  parent    CostCenter?    @relation("CostCenterHierarchy", fields: [parentId], references: [id])
  children  CostCenter[]   @relation("CostCenterHierarchy")
  expenses  Expense[]
  revenues  Revenue[]

  @@map("cost_centers")
}

model Expense {
  id              String               @id @default(cuid())
  category        String
  costCenterId    String?
  description     String
  totalAmount     Float
  dueDate         DateTime
  paymentDate     DateTime?
  isPaid          Boolean              @default(false)
  impactsCashFlow Boolean              @default(true)
  purchaseId      String?
  penId           String?
  vendorId        String?
  payerAccountId  String?
  userId          String
  cycleId         String?
  notes           String?
  createdAt       DateTime             @default(now())
  updatedAt       DateTime             @updatedAt
  allocations     ExpenseAllocation[]
  costCenter      CostCenter?          @relation(fields: [costCenterId], references: [id])
  purchase        CattlePurchase?      @relation(fields: [purchaseId], references: [id])
  payerAccount    PayerAccount?        @relation(fields: [payerAccountId], references: [id])
  cycle           Cycle?               @relation(fields: [cycleId], references: [id])
  reconciliations ReconciliationItem[]

  @@map("expenses")
}

model Revenue {
  id              String               @id @default(cuid())
  category        String
  costCenterId    String?
  description     String
  totalAmount     Float
  dueDate         DateTime
  receiptDate     DateTime?
  isReceived      Boolean              @default(false)
  saleRecordId    String?
  buyerId         String?
  payerAccountId  String?
  cycleId         String?
  userId          String
  notes           String?
  createdAt       DateTime             @default(now())
  updatedAt       DateTime             @updatedAt
  reconciliations ReconciliationItem[]
  allocations     RevenueAllocation[]
  costCenter      CostCenter?          @relation(fields: [costCenterId], references: [id])
  payerAccount    PayerAccount?        @relation(fields: [payerAccountId], references: [id])
  cycle           Cycle?               @relation(fields: [cycleId], references: [id])

  @@map("revenues")
}

model NonCashExpense {
  id            String         @id @default(cuid())
  type          NonCashType
  purchaseId    String
  description   String
  quantity      Int?
  expectedValue Float?
  actualValue   Float?
  totalValue    Float
  recordDate    DateTime
  notes         String?
  createdAt     DateTime       @default(now())
  purchase      CattlePurchase @relation(fields: [purchaseId], references: [id])

  @@map("non_cash_expenses")
}

model ExpenseAllocation {
  id              String           @id @default(cuid())
  expenseId       String
  entityType      AllocationEntity
  entityId        String
  allocatedAmount Float
  percentage      Float
  createdAt       DateTime         @default(now())
  expense         Expense          @relation(fields: [expenseId], references: [id])

  @@map("expense_allocations")
}

model RevenueAllocation {
  id              String           @id @default(cuid())
  revenueId       String
  entityType      AllocationEntity
  entityId        String
  allocatedAmount Float
  percentage      Float
  createdAt       DateTime         @default(now())
  revenue         Revenue          @relation(fields: [revenueId], references: [id])

  @@map("revenue_allocations")
}

model FinancialContribution {
  id               String           @id @default(cuid())
  type             ContributionType
  partnerId        String
  payerAccountId   String
  amount           Float
  contributionDate DateTime
  description      String?
  userId           String
  createdAt        DateTime         @default(now())
  updatedAt        DateTime         @updatedAt
  partner          Partner          @relation(fields: [partnerId], references: [id])
  payerAccount     PayerAccount     @relation(fields: [payerAccountId], references: [id])

  @@map("financial_contributions")
}

model FinancialAccount {
  id              String                 @id @default(cuid())
  type            AccountTransactionType
  category        String
  purchaseId      String?
  description     String
  amount          Float
  dueDate         DateTime
  paymentDate     DateTime?
  status          TransactionStatus      @default(PENDING)
  notes           String?
  createdAt       DateTime               @default(now())
  updatedAt       DateTime               @updatedAt
  purchase        CattlePurchase?        @relation(fields: [purchaseId], references: [id])

  @@map("financial_accounts")
}

model BankStatement {
  id              String               @id @default(cuid())
  payerAccountId  String
  statementDate   DateTime
  description     String
  amount          Float
  balance         Float
  transactionType String
  reference       String?
  importBatchId   String?
  isReconciled    Boolean              @default(false)
  userId          String
  createdAt       DateTime             @default(now())
  updatedAt       DateTime             @updatedAt
  payerAccount    PayerAccount         @relation(fields: [payerAccountId], references: [id])
  reconciliations ReconciliationItem[]

  @@map("bank_statements")
}

model FinancialReconciliation {
  id                 String               @id @default(cuid())
  payerAccountId     String
  reconciliationDate DateTime
  status             ReconciliationStatus
  totalReconciled    Float
  userId             String
  notes              String?
  createdAt          DateTime             @default(now())
  updatedAt          DateTime             @updatedAt
  payerAccount       PayerAccount         @relation(fields: [payerAccountId], references: [id])
  items              ReconciliationItem[]

  @@map("financial_reconciliations")
}

model ReconciliationItem {
  id               String                        @id @default(cuid())
  reconciliationId String
  bankStatementId  String
  transactionType  ReconciliationTransactionType
  transactionId    String?
  amount           Float
  createdAt        DateTime                      @default(now())
  bankStatement    BankStatement                 @relation(fields: [bankStatementId], references: [id])
  expense          Expense?                      @relation(fields: [transactionId], references: [id], map: "reconciliation_items_expense_fkey")
  reconciliation   FinancialReconciliation       @relation(fields: [reconciliationId], references: [id])
  revenue          Revenue?                      @relation(fields: [transactionId], references: [id], map: "reconciliation_items_revenue_fkey")

  @@map("reconciliation_items")
}

model Notification {
  id        String           @id @default(cuid())
  userId    String
  type      NotificationType
  title     String
  message   String
  data      Json?
  isRead    Boolean          @default(false)
  readAt    DateTime?
  createdAt DateTime         @default(now())

  @@map("notifications")
}

model AuditLog {
  id        String   @id @default(cuid())
  userId    String
  action    String
  entity    String
  entityId  String
  oldData   Json?
  newData   Json?
  ipAddress String?
  userAgent String?
  createdAt DateTime @default(now())

  @@index([entity, entityId])
  @@index([userId, createdAt])
  @@map("audit_logs")
}

model Cycle {
  id            String           @id @default(cuid())
  name          String
  description   String?
  startDate     DateTime
  endDate       DateTime?
  status        CycleStatus      @default(PLANNED)
  budget        Float            @default(0)
  targetAnimals Int              @default(0)
  actualAnimals Int              @default(0)
  totalCost     Float            @default(0)
  totalRevenue  Float            @default(0)
  isActive      Boolean          @default(true)
  createdAt     DateTime         @default(now())
  updatedAt     DateTime         @updatedAt
  
  // Relacionamentos
  cattlePurchases CattlePurchase[]
  expenses        Expense[]
  revenues        Revenue[]
  saleRecords     SaleRecord[]
  
  @@map("cycles")
}

/// This model contains row level security and requires additional setup for migrations. Visit https://pris.ly/d/row-level-security for more info.
model users_sync {
  id        String    @id @db.Uuid
  email     String    @unique
  name      String?
  role      String?   @default("USER")
  isMaster  Boolean?  @default(false)
  isActive  Boolean?  @default(true)
  createdAt DateTime? @default(now()) @db.Timestamptz(6)
  updatedAt DateTime? @default(now()) @db.Timestamptz(6)
}

enum UserRole {
  ADMIN
  MANAGER
  USER
  VIEWER
}

enum PartnerType {
  VENDOR
  BROKER
  BUYER
  INVESTOR
  SERVICE_PROVIDER
  OTHER
  FREIGHT_CARRIER
}

enum AccountType {
  CHECKING
  SAVINGS
  INVESTMENT
  CASH
}

enum AnimalType {
  MALE
  FEMALE
  MIXED
}

enum PaymentType {
  CASH
  INSTALLMENT
  MIXED
}

// Enums PurchaseOrderStatus e LotStatus removidos - agora usando PurchaseStatus unificado

enum PenType {
  RECEPTION
  FATTENING
  QUARANTINE
  HOSPITAL
}

enum PenStatus {
  AVAILABLE
  OCCUPIED
  MAINTENANCE
  QUARANTINE
}

enum LinkStatus {
  ACTIVE
  REMOVED
}

enum CostSourceType {
  HEALTH
  FEED
  OPERATIONAL
  OTHER
  PURCHASE_ORDER
}

enum ProtocolType {
  VACCINATION
  MEDICATION
  EXAMINATION
  TREATMENT
  OTHER
}

enum MovementType {
  ALLOCATION
  TRANSFER
  REMOVAL
  DEATH
  SALE
}

enum SaleStatus {
  NEXT_SLAUGHTER
  SCHEDULED
  SHIPPED
  SLAUGHTERED
  RECONCILED
  CANCELLED
}

enum CostCenterType {
  ACQUISITION
  FATTENING
  ADMINISTRATIVE
  FINANCIAL
  REVENUE
  CONTRIBUTION
}

enum NonCashType {
  MORTALITY
  WEIGHT_LOSS
  DEPRECIATION
  ADJUSTMENT
  OTHER
}

enum AllocationEntity {
  LOT
  PEN
  GLOBAL
}

enum ContributionType {
  PARTNER_CONTRIBUTION
  PARTNER_LOAN
  BANK_FINANCING
  EXTERNAL_INVESTOR
}

enum AccountTransactionType {
  PAYABLE
  RECEIVABLE
}

enum TransactionStatus {
  PENDING
  PAID
  RECEIVED
  OVERDUE
  CANCELLED
}

enum ReconciliationStatus {
  DRAFT
  COMPLETED
  CANCELLED
}

enum ReconciliationTransactionType {
  EXPENSE
  REVENUE
  CONTRIBUTION
  TRANSFER
}

enum NotificationType {
  PAYMENT_DUE
  PAYMENT_OVERDUE
  SALE_COMPLETED
  SYSTEM_UPDATE
  ALERT
  INFO
}

enum CycleStatus {
  PLANNED
  ACTIVE
  COMPLETED
  CANCELLED
}
