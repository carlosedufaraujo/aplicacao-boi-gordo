import { Request, Response } from 'express';
import { catchAsync } from '../utils/catchAsync';
import calendarEventService, { CalendarEventFilters } from '../services/calendarEvent.service';
import { EventType, EventStatus, EventPriority } from '@prisma/client';

export const CalendarEventController = {
  // Listar eventos com filtros
  getEvents: catchAsync(async (req: Request, res: Response) => {
    const {
      startDate,
      endDate,
      type,
      status,
      priority,
      userId,
      cycleId,
      tags,
      autoGenerated
    } = req.query;

    const filters: CalendarEventFilters = {};

    if (startDate) filters.startDate = new Date(startDate as string);
    if (endDate) filters.endDate = new Date(endDate as string);
    if (type) filters.type = type as EventType;
    if (status) filters.status = status as EventStatus;
    if (priority) filters.priority = priority as EventPriority;
    if (userId) filters.userId = userId as string;
    if (cycleId) filters.cycleId = cycleId as string;
    if (autoGenerated !== undefined) filters.autoGenerated = autoGenerated === 'true';
    if (tags) {
      filters.tags = Array.isArray(tags) ? tags as string[] : [tags as string];
    }

    const events = await calendarEventService.findEvents(filters);

    res.json({
      status: 'success',
      data: events
    });
  }),

  // Obter um evento específico
  getEvent: catchAsync(async (req: Request, res: Response) => {
    const { id } = req.params;
    const event = await calendarEventService.findById(id);

    if (!event) {
      return res.status(404).json({
        status: 'error',
        message: 'Evento não encontrado'
      });
    }

    res.json({
      status: 'success',
      data: event
    });
  }),

  // Criar novo evento
  createEvent: catchAsync(async (req: Request, res: Response) => {
    const {
      title,
      description,
      type,
      date,
      time,
      location,
      participants,
      status,
      priority,
      recurring,
      tags,
      color,
      relatedId,
      amount,
      cycleId
    } = req.body;

    const event = await calendarEventService.createEvent({
      title,
      description,
      type,
      date: new Date(date),
      time,
      location,
      participants,
      status,
      priority,
      recurring,
      tags,
      color,
      relatedId,
      amount: amount ? parseFloat(amount) : undefined,
      userId: req.user?.id,
      cycleId
    });

    res.status(201).json({
      status: 'success',
      data: event
    });
  }),

  // Atualizar evento existente
  updateEvent: catchAsync(async (req: Request, res: Response) => {
    const { id } = req.params;
    const {
      title,
      description,
      type,
      date,
      time,
      location,
      participants,
      status,
      priority,
      recurring,
      tags,
      color,
      relatedId,
      amount,
      cycleId
    } = req.body;

    const event = await calendarEventService.updateEvent(id, {
      title,
      description,
      type,
      date: date ? new Date(date) : undefined,
      time,
      location,
      participants,
      status,
      priority,
      recurring,
      tags,
      color,
      relatedId,
      amount: amount ? parseFloat(amount) : undefined,
      cycleId
    });

    res.json({
      status: 'success',
      data: event
    });
  }),

  // Excluir evento
  deleteEvent: catchAsync(async (req: Request, res: Response) => {
    const { id } = req.params;
    await calendarEventService.deleteEvent(id);

    res.json({
      status: 'success',
      message: 'Evento excluído com sucesso'
    });
  }),

  // Obter estatísticas de eventos
  getEventStats: catchAsync(async (req: Request, res: Response) => {
    const {
      startDate,
      endDate,
      userId,
      cycleId
    } = req.query;

    const filters: CalendarEventFilters = {};
    if (startDate) filters.startDate = new Date(startDate as string);
    if (endDate) filters.endDate = new Date(endDate as string);
    if (userId) filters.userId = userId as string;
    if (cycleId) filters.cycleId = cycleId as string;

    const stats = await calendarEventService.getEventStats(filters);

    res.json({
      status: 'success',
      data: stats
    });
  }),

  // Gerar eventos automáticos
  generateAutoEvents: catchAsync(async (req: Request, res: Response) => {
    const events = await calendarEventService.generateAutomaticEvents(req.user?.id);

    res.json({
      status: 'success',
      data: events,
      message: `${events.length} eventos automáticos foram gerados`
    });
  }),

  // Atualizar eventos em atraso
  updateOverdueEvents: catchAsync(async (req: Request, res: Response) => {
    const count = await calendarEventService.updateOverdueEvents();

    res.json({
      status: 'success',
      data: { updatedCount: count },
      message: `${count} eventos foram marcados como atrasados`
    });
  }),

  // Marcar evento como concluído
  completeEvent: catchAsync(async (req: Request, res: Response) => {
    const { id } = req.params;
    
    const event = await calendarEventService.updateEvent(id, {
      status: EventStatus.COMPLETED
    });

    res.json({
      status: 'success',
      data: event,
      message: 'Evento marcado como concluído'
    });
  }),

  // Cancelar evento
  cancelEvent: catchAsync(async (req: Request, res: Response) => {
    const { id } = req.params;
    
    const event = await calendarEventService.updateEvent(id, {
      status: EventStatus.CANCELLED
    });

    res.json({
      status: 'success',
      data: event,
      message: 'Evento cancelado'
    });
  })
};