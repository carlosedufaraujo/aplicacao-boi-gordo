import { PrismaClient, CalendarEvent, EventType, EventStatus, EventPriority, Prisma } from '@prisma/client';

const prisma = new PrismaClient();

export interface CreateCalendarEventData {
  title: string;
  description?: string;
  type: EventType;
  date: Date;
  time?: string;
  location?: string;
  participants?: string[];
  status?: EventStatus;
  priority?: EventPriority;
  recurring?: boolean;
  tags?: string[];
  color?: string;
  relatedId?: string;
  amount?: number;
  autoGenerated?: boolean;
  userId?: string;
}

export interface UpdateCalendarEventData {
  title?: string;
  description?: string;
  type?: EventType;
  date?: Date;
  time?: string;
  location?: string;
  participants?: string[];
  status?: EventStatus;
  priority?: EventPriority;
  recurring?: boolean;
  tags?: string[];
  color?: string;
  relatedId?: string;
  amount?: number;
}

export interface CalendarEventFilters {
  startDate?: Date;
  endDate?: Date;
  type?: EventType;
  status?: EventStatus;
  priority?: EventPriority;
  userId?: string;
  tags?: string[];
  autoGenerated?: boolean;
}

export interface CalendarEventStats {
  totalEvents: number;
  eventsByType: Record<string, number>;
  eventsByStatus: Record<string, number>;
  overdueEvents: number;
  upcomingEvents: number;
  thisMonthEvents: number;
  highPriorityEvents: number;
}

export class CalendarEventService {

  /**
   * Busca eventos com filtros avançados
   */
  async findEvents(filters: CalendarEventFilters = {}): Promise<CalendarEvent[]> {
    const where: Prisma.CalendarEventWhereInput = {};

    // Filtros de data
    if (filters.startDate && filters.endDate) {
      where.date = {
        gte: filters.startDate,
        lte: filters.endDate
      };
    } else if (filters.startDate) {
      where.date = { gte: filters.startDate };
    } else if (filters.endDate) {
      where.date = { lte: filters.endDate };
    }

    // Outros filtros
    if (filters.type) where.type = filters.type;
    if (filters.status) where.status = filters.status;
    if (filters.priority) where.priority = filters.priority;
    if (filters.userId) where.userId = filters.userId;
    if (filters.autoGenerated !== undefined) where.autoGenerated = filters.autoGenerated;
    
    // Filtro por tags
    if (filters.tags && filters.tags.length > 0) {
      where.tags = {
        hasEvery: filters.tags
      };
    }

    return await prisma.calendarEvent.findMany({
      where,
      orderBy: { date: 'asc' }
    });
  }

  /**
   * Busca evento por ID relacionado (para integração com outros módulos)
   */
  async findEventByRelatedId(relatedId: string): Promise<CalendarEvent | null> {
    return await prisma.calendarEvent.findFirst({
      where: { relatedId }
    });
  }

  /**
   * Cria um novo evento de calendário
   */
  async createEvent(data: CreateCalendarEventData): Promise<CalendarEvent> {
    const eventData: Prisma.CalendarEventCreateInput = {
      title: data.title,
      description: data.description,
      type: data.type,
      date: data.date,
      time: data.time,
      location: data.location,
      participants: data.participants || [],
      status: data.status || EventStatus.SCHEDULED,
      priority: data.priority || EventPriority.MEDIUM,
      recurring: data.recurring || false,
      tags: data.tags || [],
      color: data.color,
      relatedId: data.relatedId,
      amount: data.amount,
      autoGenerated: data.autoGenerated || false,
      userId: data.userId
    };

    return await prisma.calendarEvent.create({
      data: eventData
    });
  }

  /**
   * Atualiza um evento existente
   */
  async updateEvent(id: string, data: UpdateCalendarEventData): Promise<CalendarEvent> {
    const updateData: Prisma.CalendarEventUpdateInput = {};

    // Mapear campos para atualização
    if (data.title !== undefined) updateData.title = data.title;
    if (data.description !== undefined) updateData.description = data.description;
    if (data.type !== undefined) updateData.type = data.type;
    if (data.date !== undefined) updateData.date = data.date;
    if (data.time !== undefined) updateData.time = data.time;
    if (data.location !== undefined) updateData.location = data.location;
    if (data.participants !== undefined) updateData.participants = data.participants;
    if (data.status !== undefined) updateData.status = data.status;
    if (data.priority !== undefined) updateData.priority = data.priority;
    if (data.recurring !== undefined) updateData.recurring = data.recurring;
    if (data.tags !== undefined) updateData.tags = data.tags;
    if (data.color !== undefined) updateData.color = data.color;
    if (data.relatedId !== undefined) updateData.relatedId = data.relatedId;
    if (data.amount !== undefined) updateData.amount = data.amount;

    return await prisma.calendarEvent.update({
      where: { id },
      data: updateData
    });
  }

  /**
   * Remove um evento
   */
  async deleteEvent(id: string): Promise<CalendarEvent> {
    return await prisma.calendarEvent.delete({
      where: { id }
    });
  }

  /**
   * Obtém estatísticas dos eventos
   */
  async getEventStats(filters: CalendarEventFilters = {}): Promise<CalendarEventStats> {
    const where: Prisma.CalendarEventWhereInput = {};

    // Aplicar filtros básicos
    if (filters.startDate && filters.endDate) {
      where.date = { gte: filters.startDate, lte: filters.endDate };
    }
    if (filters.userId) where.userId = filters.userId;

    // Total de eventos
    const totalEvents = await prisma.calendarEvent.count({ where });

    // Eventos por tipo
    const eventsByType = await prisma.calendarEvent.groupBy({
      by: ['type'],
      where,
      _count: { type: true }
    });

    // Eventos por status
    const eventsByStatus = await prisma.calendarEvent.groupBy({
      by: ['status'],
      where,
      _count: { status: true }
    });

    // Eventos em atraso (data passou e status não é COMPLETED/CANCELLED)
    const overdueEvents = await prisma.calendarEvent.count({
      where: {
        ...where,
        date: { lt: new Date() },
        status: {
          notIn: [EventStatus.COMPLETED, EventStatus.CANCELLED]
        }
      }
    });

    // Eventos próximos (próximos 7 dias)
    const upcomingEvents = await prisma.calendarEvent.count({
      where: {
        ...where,
        date: {
          gte: new Date(),
          lte: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)
        },
        status: {
          in: [EventStatus.SCHEDULED, EventStatus.IN_PROGRESS]
        }
      }
    });

    // Eventos deste mês
    const startOfMonth = new Date();
    startOfMonth.setDate(1);
    startOfMonth.setHours(0, 0, 0, 0);
    
    const endOfMonth = new Date();
    endOfMonth.setMonth(endOfMonth.getMonth() + 1);
    endOfMonth.setDate(0);
    endOfMonth.setHours(23, 59, 59, 999);

    const thisMonthEvents = await prisma.calendarEvent.count({
      where: {
        ...where,
        date: { gte: startOfMonth, lte: endOfMonth }
      }
    });

    // Eventos de alta prioridade pendentes
    const highPriorityEvents = await prisma.calendarEvent.count({
      where: {
        ...where,
        priority: { in: [EventPriority.HIGH, EventPriority.URGENT] },
        status: { in: [EventStatus.SCHEDULED, EventStatus.IN_PROGRESS] }
      }
    });

    return {
      totalEvents,
      eventsByType: eventsByType.reduce((acc, item) => {
        acc[item.type] = item._count.type;
        return acc;
      }, {} as Record<string, number>),
      eventsByStatus: eventsByStatus.reduce((acc, item) => {
        acc[item.status] = item._count.status;
        return acc;
      }, {} as Record<string, number>),
      overdueEvents,
      upcomingEvents,
      thisMonthEvents,
      highPriorityEvents
    };
  }

  /**
   * Gera eventos automáticos baseados em outros dados do sistema
   */
  async generateAutomaticEvents(userId?: string): Promise<CalendarEvent[]> {
    const generatedEvents: CalendarEvent[] = [];

    // Buscar despesas com vencimento
    const expenses = await prisma.expense.findMany({
      where: {
        isPaid: false,
        dueDate: { not: null },
        userId: userId
      }
    });

    for (const expense of expenses) {
      if (!expense.dueDate) continue;

      const existingEvent = await prisma.calendarEvent.findFirst({
        where: {
          relatedId: expense.id,
          autoGenerated: true
        }
      });

      if (!existingEvent) {
        const event = await this.createEvent({
          title: `Vencimento: ${expense.description}`,
          description: `Despesa de ${expense.category}`,
          type: EventType.FINANCE,
          date: expense.dueDate,
          status: expense.dueDate < new Date() ? EventStatus.OVERDUE : EventStatus.SCHEDULED,
          priority: expense.dueDate < new Date() ? EventPriority.HIGH : EventPriority.MEDIUM,
          relatedId: expense.id,
          amount: expense.totalAmount,
          autoGenerated: true,
          userId: expense.userId
        });
        generatedEvents.push(event);
      }
    }

    // Buscar receitas programadas
    const revenues = await prisma.revenue.findMany({
      where: {
        isReceived: false,
        dueDate: { not: null },
        userId: userId
      }
    });

    for (const revenue of revenues) {
      if (!revenue.dueDate) continue;

      const existingEvent = await prisma.calendarEvent.findFirst({
        where: {
          relatedId: revenue.id,
          autoGenerated: true
        }
      });

      if (!existingEvent) {
        const event = await this.createEvent({
          title: `Recebimento: ${revenue.description}`,
          description: `Receita de ${revenue.category}`,
          type: EventType.FINANCE,
          date: revenue.dueDate,
          status: EventStatus.SCHEDULED,
          priority: EventPriority.MEDIUM,
          relatedId: revenue.id,
          amount: revenue.totalAmount,
          autoGenerated: true,
          userId: revenue.userId
        });
        generatedEvents.push(event);
      }
    }

    return generatedEvents;
  }

  /**
   * Atualiza o status de eventos em atraso
   */
  async updateOverdueEvents(): Promise<number> {
    const result = await prisma.calendarEvent.updateMany({
      where: {
        date: { lt: new Date() },
        status: { in: [EventStatus.SCHEDULED, EventStatus.IN_PROGRESS] }
      },
      data: {
        status: EventStatus.OVERDUE
      }
    });

    return result.count;
  }

  /**
   * Busca evento por ID
   */
  async findById(id: string): Promise<CalendarEvent | null> {
    return await prisma.calendarEvent.findUnique({
      where: { id }
    });
  }
}

export default new CalendarEventService();